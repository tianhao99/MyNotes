# 尚硅谷书城项目笔记

## 1、JavaEE 项目的三层架构

![image-20211108185108293](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211108185108293.png)



分层的目的是为了解耦。 解耦就是为了降低代码的耦合度。 方便项目后期的维护和升级。  



web 层										com.atguigu.web/servlet/controller								

service 层									com.atguigu.service和com.atguigu.service.impl				

| web 层             | com.atguigu.web/servlet/controller      |                        |
| ------------------ | --------------------------------------- | ---------------------- |
| **service 层**     | **com.atguigu.service**                 | **Service 接口包**     |
|                    | **com.atguigu.service.impl**            | **Service 接口实现类** |
| **dao 持久层**     | **com.atguigu.dao**                     | **Dao 接口包**         |
|                    | **com.atguigu.dao.impl**                | **Dao 接口实现类**     |
| **实体 bean 对象** | **com.atguigu.pojo/entity/domain/bean** | **JavaBean 类**        |
| **测试包**         | **com.atguigu.test/junit**              |                        |
| **工具类**         | **com.atguigu.utils**                   |                        |



## 2、搭建书城项目开发环境

![image-20211108190859081](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211108190859081.png)



## 3、先创建书城需要的数据库和表



```sql
-- 判断books数据库是否存在，存在就删除
drop database if exists books;

-- 创建books数据库
create database books;

-- 切换到books数据库
use books;

-- 创建用户注册需要的表格
create table t_user(
	`id` int primary key auto_increment,
	`username` varchar(20) not null unique,  -- 不空且唯一
	`password` varchar(32) not null,
	`email` varchar(200)
);

-- 插入测试，并查询
insert into t_user(`username`,`password`,`email`) values('admin','admin','1221221@qq.com');

select * from t_user;
```



## 4、编写数据表对应的 JavaBean 对象

**User 数据库对应类：**

```java
package com.tianhao.bean;

/**
 * @ClassName User
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/8 19:23
 * @Version 1.0
 */
public class User {
    
    // Fields
    private Integer id;
    private String username;
    private String password;
    private String email;
   
    // Constructors
    public User() {}
    public User(Integer id, String username, String password, String email) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.email = email;
    }
    
    // Methods
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", email='" + email + '\'' +
                '}';
    }
}
```



## 5、编写 工具类 JDBCUtils

- 第一步：导入文件
	- 导入数据库连接驱动 jar包
	- 导入数据库连接池 jar包
	- 导入数据库配置文件 jdbc.properties
- 注意：
	- 新版IDEA 配置文件放在 src/main/resources目录下，调用时还是直接写文件名就能搜到
	- jar包 统一在src\main\webapp\WEB-INF\lib 中存放，lib是需要手动创建的文件夹

![image-20211108221845995](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211108221845995.png)



![image-20211108222019928](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211108222019928.png)



- 第二步：编写工具类

```java
package com.tianhao.utils;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Properties;

/**
 * @ClassName JdbcUtils
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/8 21:29
 * @Version 1.0
 */
public class JdbcUtils {
    /**
     * 获取数据库连接池中的连接
     * @return null表示获取连接失败，有值就是成功
     */
    private static DataSource sourceDruid;
    //同理，将数据库连接池的创建放到外边，要不然创建n个池子干啥
    //因为涉及到流加载，不能直接声明，通过声明静态代码块，随着类的加载而加载
    static{
        try {
            Properties pros = new Properties();
            // 读取jdbc.properties 属性配置文件
//            InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("jdbc.properties");
            InputStream is = JdbcUtils.class.getClassLoader().getResourceAsStream("jdbc.properties");
            // 从流中加载数据
            pros.load(is);
            // 创建数据库连接池
            sourceDruid = DruidDataSourceFactory.createDataSource(pros);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static Connection getConnection(){
        Connection connection = null;
        try {
            connection = sourceDruid.getConnection();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return connection;
    }

    /**
     * 关闭连接，放回数据库连接池
     * @param conn 要关闭的连接
     */
    public static void close(Connection conn){
        if (conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```



## 6、编写BaseDao 类

- 先导入数据库操作 jar 包

![image-20211108225237243](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211108225237243.png)

**BaseDao抽象类：**

```java
package com.tianhao.dao.impl;

import com.tianhao.utils.JdbcUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

/**
 * @ClassName BaseDao
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/8 22:30
 * @Version 1.0
 */
public abstract class BaseDao {
    // 使用DbUtils 操作数据库
    private QueryRunner queryRunner = new QueryRunner();

    /**
     * update用来实现 insert/update/delete语句
     * @param sql sql语句
     * @param args 占位符
     * @return 如果返回-1，表示执行失败，否则返回受影响行数
     */
    public int update(String sql,Object ...args){
        Connection conn = JdbcUtils.getConnection();
        try {
            return queryRunner.update(conn,sql,args); // 返回受影响行数
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.close(conn);
        }
        return -1; // 执行失败
    }

    /**
     * 查询返回一个JavaBean的sql语句
     * @param type 返回对象类型
     * @param sql 执行的SQL语句
     * @param args 占位符，SQL语句的参数
     * @param <T> 返回的类型的泛型
     * @return
     */
    public <T> T queryForOne(Class<T> type,String sql,Object ...args){
        Connection conn = JdbcUtils.getConnection();
        try {
            return queryRunner.query(conn,sql,new BeanHandler<T>(type),args);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.close(conn);
        }
        return null;
    }

    /**
     * 查询多个结果，返回对象数组
     * @param type 返回对象类型
     * @param sql 执行的SQL语句
     * @param args 占位符，SQL语句的参数
     * @param <T> 返回的类型的泛型
     * @return
     */
    public <T> List<T> queryForList(Class<T> type,String sql,Object ...args){
        Connection conn = JdbcUtils.getConnection();
        try {
            return queryRunner.query(conn,sql,new BeanListHandler<T>(type),args);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.close(conn);
        }
        return null;
    }

    /**
     * 查询单个值，最大值、最小值、总行数之类的
     * @param sql
     * @param args
     * @return
     */
    public Object queryForSingleValue(String sql,Object ...args){
        Connection conn = JdbcUtils.getConnection();
        try {
            return queryRunner.query(conn,sql,new ScalarHandler(),args);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.close(conn);
        }
        return null;
    }
}
```



## 7、编写UserDao和测试



**UserDao接口：**

```java
package com.tianhao.dao;

import com.tianhao.bean.User;

/**
 * @ClassName UserDao
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/8 22:57
 * @Version 1.0
 */
public interface UserDao {
    /**
     * 根据用户名查询用户信息【注册，判断用户名是否可用、或单纯查询信息】
     * @param username 用户名
     * @return 如果返回null，说明用户名可用，或用户不存在
     */
    public User queryUsername(String username);

    /**
     * 根据用户名和密码查询用户【登录，判断用户信息是否存在】
     * @param username
     * @param password
     * @return 如果返回null，说明用户不存在
     */
    public User queryUsernameAndPassword(String username,String password);

    /**
     * 保存注册用户的信息【注册用】
     * @param user
     * @return
     */
    public int saveUser(User user);
}
```



**UserDaoImpl类，实现UseDao接口：**

```java
package com.tianhao.dao.impl;

import com.tianhao.bean.User;
import com.tianhao.dao.UserDao;
import org.junit.Test;

/**
 * @ClassName UserDaoImpl
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/8 23:03
 * @Version 1.0
 */
public class UserDaoImpl extends BaseDao implements UserDao {

    @Override
    public User queryUsername(String username) {
        String sql = "select `id`,`username`,`password`,`email` from t_user where `username`=?";
        return queryForOne(User.class, sql, username);
    }

    @Override
    public User queryUsernameAndPassword(String username, String password) {
        String sql = "select `id`,`username`,`password`,`email` from t_user where `username`=? And `password`=?";
        return queryForOne(User.class, sql, username,password);
    }

    @Override
    public int saveUser(User user) {
        String sql = "insert into t_user(`username`,`password`,`email`)value(?,?,?)";
        return update(sql,user.getUsername(),user.getPassword(),user.getEmail());
    }
}
```

**UserDaoImplTest 测试类：**

```java
package com.tianhao.test;

import com.tianhao.bean.User;
import com.tianhao.dao.UserDao;
import com.tianhao.dao.impl.UserDaoImpl;
import org.junit.jupiter.api.Test;


/**
 * @ClassName UserDaoImplTest
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/8 23:13
 * @Version 1.0
 */
class UserDaoImplTest {
    UserDao userDao = new UserDaoImpl();

    @Test
    void queryUsername() {
        System.out.println(userDao.queryUsername("张三丰"));
        System.out.println(userDao.queryUsername("张无忌"));
        if (userDao.queryUsername("admin") == null){
            System.out.println("用户名可用！");
        }else{
            System.out.println("用户名已存在！");
        }
    }

    @Test
    void queryUsernameAndPassword() {

        if (userDao.queryUsernameAndPassword("admin","admin") == null){
            System.out.println("用户或密码错误，登录失败！");
        }else{
            System.out.println("登录成功");
        }
    }

    @Test
    void saveUser() {
        User user = new User("张三丰", "guoxiang", "guoxiang@qq.com");
        if (userDao.saveUser(user) != -1){
            System.out.println("注册成功！");
        }else{
            System.out.println("注册失败！");
        }

    }
}
```



## 8、编写UserService和测试

**UserService接口：**

```java
package com.tianhao.service;

import com.tianhao.bean.User;

/**
 * @ClassName UserService
 * @Description TODO:要实现哪些功能？检查用户名是否合法？账户是否存在？
 * @Author sth_199509@163.com
 * @Date 2021/11/9 7:43
 * @Version 1.0
 */
public interface UserService {
    /**
     * 注册账户信息
     * @param user
     */
    public void registUser(User user);

    /**
     * 登录操作
     * @param user
     * @return
     */
    public User login(User user);

    /**
     * 检查 用户名是否可用
     * @param username
     * @return 返回true，表示存在，用户名不可用，返回false表示可用
     */
    public boolean existsUsername(String username);
}
```



**UserServiceImpl类 ，实现UserService接口：**

```java
package com.tianhao.service.impl;

import com.tianhao.bean.User;
import com.tianhao.dao.UserDao;
import com.tianhao.dao.impl.UserDaoImpl;
import com.tianhao.service.UserService;

/**
 * @ClassName UserServiceImpl
 * @Description TODO:UserService接口的实现类
 * @Author sth_199509@163.com
 * @Date 2021/11/9 7:50
 * @Version 1.0
 */
public class UserServiceImpl implements UserService {
    // 因为相应的功能需要 操作数据库，所以创建一个UserDaoImpl类的对象
    private UserDao userDao = new UserDaoImpl();
    @Override
    public void registUser(User user) {
        userDao.saveUser(user);
    }

    @Override
    public User login(User user) {
        return userDao.queryUsernameAndPassword(user.getUsername(),user.getPassword());
    }

    @Override
    public boolean existsUsername(String username) {
        if (userDao.queryUsername(username) == null){
            // 说明没查到，表示可用，返回false
            // 为什么要返回false呢？因为方法名是，existsUsername【存在用户A吗，不存在返回false】
            return false;
        }else{
            return true;
        }
    }
}

```



**UserServiceImpl的测试类：**

```java
package com.tianhao.test;

import com.tianhao.bean.User;
import com.tianhao.service.UserService;
import com.tianhao.service.impl.UserServiceImpl;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * @ClassName UserServiceImplTest
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/9 8:00
 * @Version 1.0
 */
class UserServiceImplTest {
    UserService userService = new UserServiceImpl();
    @Test
    void registUser() {
        User user = new User(null,"杨过","xiaolongnv","xiaolongnv@126.com");
        userService.registUser(user);
    }

    @Test
    void login() {
        User user = new User(null, "admin", "admin", "12345@qq.com");
        userService.login(user);
    }

    @Test
    void existsUsername() {
        if (userService.existsUsername("张无忌")){
            System.out.println("用户名可用！");
        }else{
            System.out.println("用户名已存在！");
        }
    }
}
```



## 9、编写Web层

### 一、实现用户注册的功能

#### 1、**流程：**

![image-20211109082120059](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211109082120059.png)



#### 2、修改 regist.html 和 regist_success.html 页面

- 添加 base 标签 【一般放在<title>标签下面】

	```xml
	<!--写 base 标签， 永远固定相对路径跳转的结果【最后记得加斜杠】-->
	<base href="http://localhost:8080/Books/">   
	```

- 修改 base 标签对页面中所有相对路径的影响（浏览器 F12， 哪个报红， 改哪个）  

- ![image-20211109084731535](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211109084731535.png)

	```xml
	以下是几个修改的示例：
	<link type="text/css" rel="stylesheet" href="static/css/style.css" >
	<script type="text/javascript" src="static/script/jquery-1.7.2.js"></script>
	```

- 修改路径时，记得开启服务器部署，开启后base地址默认跳转到webapp目录下，再修改相应的地址即可，若不开启部署，直接运行html文件，默认base地址在Books目录下，导致修改后，开启服务器还是会找不到相关文件

- 修改注册表单的提交地址和请求方式

	![image-20211109082444409](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211109082444409.png)

#### 3、注册代码

```java
package com.tianhao.web; /**
 * @ClassName ${NAME}
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/9 8:26
 * @Version 1.0
 */

import com.tianhao.bean.User;
import com.tianhao.dao.impl.UserDaoImpl;
import com.tianhao.service.impl.UserServiceImpl;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.IOException;

public class RegistServlet extends HttpServlet {
    UserServiceImpl userService = new UserServiceImpl();
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 1、获取请求参数
        String username = request.getParameter("username");
        String password = request.getParameter("password");
        String email = request.getParameter("email");
        String code = request.getParameter("code");

        // 2、验证验证码是否正确   【暂时先写死，认定为abcd，后边在提供动态验证码】
        if ("abcd".equalsIgnoreCase(code)){
            // 验证码正确
            // 验证账户信息
            User user = new User(null, username, password, email);

            if (userService.existsUsername(username)){
                // 该账号已存在，跳回注册页面
                System.out.println("该账号已存在,请重新输入，或找回密码");
                request.getRequestDispatcher("/pages/user/regist.html").forward(request,response);
            }else{
                // 成功注册
                // 保存用户信息
                userService.registUser(user);
                // 跳转注册成功地址
                request.getRequestDispatcher("/pages/user/regist_success.html").forward(request,response);
            }

        }else{
            // 验证码错误，跳回注册页面
            System.out.println("验证码错误，请重新输入！");
            request.getRequestDispatcher("/pages/user/regist.html").forward(request,response);
        }
    }
}
```





### 二、实现用户登录的功能【不完善，后边再完善，没修改登陆成功显式的用户名】

```java
package com.tianhao.web; /**
 * @ClassName ${NAME}
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/9 9:50
 * @Version 1.0
 */

import com.tianhao.bean.User;
import com.tianhao.service.UserService;
import com.tianhao.service.impl.UserServiceImpl;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.IOException;

public class LoginServlet extends HttpServlet {
    UserService userService = new UserServiceImpl();
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 1、获取请求参数
        String username = request.getParameter("username");
        String password = request.getParameter("password");
        User user = new User(null, username, password, null);
        // 2、验证登录
        User login = userService.login(user);
        if (login != null){
            // 找到该用户信息
            request.getRequestDispatcher("/pages/user/login_success.html").forward(request,response);
        }else if(!userService.existsUsername(username)){
            // 账号不存在
            System.out.println("用户名不存在，请检查后输入");
            request.getRequestDispatcher("/pages/user/login.html").forward(request,response);
        }else{
            // 账号存在，但还是找不到，说明密码错我
            System.out.println("密码错误，请检查后输入");
            request.getRequestDispatcher("/pages/user/login.html").forward(request,response);
        }
    }
}
```

------



下面是拿到一个html文件的工程，要做的一些步骤

------



## 10、页面 jsp 动态化

1、 在 html 页面顶行添加 page 指令。

![image-20211112075323410](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112075323410.png)

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
```

2、 修改html文件后缀名为： .jsp
3、 使用 IDEA 搜索替换.html 为.jsp，因为还有许多字符串中引用了HTML文件，所以选中最大的包，全局替换

【快捷键： Ctrl+Shift+R】

![image-20211112075415852](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112075415852.png)



## 11、抽取页面中相同的内容

### 11.1、先建一个文件夹，专门存放这些被调用的jsp文件

![image-20211112084559398](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112084559398.png)



### 11.2、寻找相同的标签信息

- **head 中 css、 jquery、 base 标签**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<base href="http://localhost:8080/Books/">
<link type="text/css" rel="stylesheet" href="static/css/style.css" >
<script type="text/javascript" src="static/script/jquery-1.7.2.js"></script>
```

- **每个页面的页脚**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<div id="bottom">
      <span>
         尚硅谷书城.Copyright &copy;2015
      </span>
</div>
```

- **登录成功后的菜单**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<div>
    <span>欢迎<span class="um_span">韩总</span>光临尚硅谷书城</span>
    <a href="../order/order.jsp">我的订单</a>
    <a href="../../index.jsp">注销</a>&nbsp;&nbsp;
    <a href="../../index.jsp">返回</a>
</div>
```

- **manager模块中的菜单栏**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<div>
    <a href="book_manager.jsp">图书管理</a>
    <a href="order_manager.jsp">订单管理</a>
    <a href="index.jsp">返回商城</a>
</div>
```

- 注意：记得将新建的jsp文件其他内容删掉，只保留头部就可以了，然后填要替换的信息

![image-20211112090003898](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112090003898.png)



### 11.3、静态包含引用

在被替换位置，直接用如下格式替换即可

```jsp
      </div>

      <%--静态包含，页脚信息  --%>
      <%@include file="/pages/common/footer.jsp"%>

</body>
```

![image-20211112090155090](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112090155090.png)

### 11.4、动态的base标签设置

因为base如果写死的话，不同地址访问会出现问题，这里写成动态的【因为我们使用了静态包含，所以只在common目录下的head.jsp文件中修改就可以了】

原head.jsp：

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<base href="http://localhost:8080/Books/">
<link type="text/css" rel="stylesheet" href="static/css/style.css" >
<script type="text/javascript" src="static/script/jquery-1.7.2.js"></script>
```

动态base修改后的head.jsp:

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%
    String basePath = request.getScheme() //http
    + "://"                               //://
    + request.getServerName()             //IP地址
    + ":"                                 // :
    + request.getServerPort()             // 端口
    + request.getContextPath()            // 路径Books
    + "/";                                // 最后别忘了斜杠/
%>

<!--写 base 标签， 永远固定相对路径跳转的结果-->
<base href="<%=basePath%>">
<link type="text/css" rel="stylesheet" href="static/css/style.css" >
<script type="text/javascript" src="static/script/jquery-1.7.2.js"></script>
```



## 12、登录， 注册错误提示， 及表单回显

【就是你输入有误，然后返回注册或登录页面以后，保存你刚才输入的必要的信息】

### 12.1、以登录回显为示例：

- Servlet 程序端需要添加回显信息到 Request 域中

![image-20211112114603417](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112114603417.png)

- jsp 页面， 需要输出回显信息【判断是不是空，空就不显示，不空就显示值】

![image-20211112114616400](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112114616400.png)



### 12.2、使用EL表达式修改 回显内容

以登录为示例：

![image-20211112120748230](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112120748230.png)



## 13、BaseServlet 的抽取

在实际的项目开发中， 一个模块， 一般只使用一个 Servlet 程序。 

【之前我们创建了两个Servlet，一个用于登录，一个用于注册】

### 13.1、代码优化一：

**合并 LoginServlet 和 RegistServlet 程序为 UserServlet 程序**

![image-20211112115023739](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112115023739.png)



**UserServlet 程序：**

- 这个UserServlet类继承BaseServlet类，不是HttpServlet
- 这个类只有两个方法，分别用于处理登录、注册。
- 后边好维护，可以直接添加其他方法，修改密码、修改用户名之类的

```java

public class UserServlet extends BaseServlet {
    
    private UserService userService = new UserServiceImpl();

    /**
     * 处理登录请求
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    protected void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 1、获取请求参数
        String username = request.getParameter("username");
        String password = request.getParameter("password");
//        User user = new User(null, username, password, null);【用下边的jar包工具类代替了这行代码】
        User user = WebUtils.copyParamToBean(request.getParameterMap(), new User());


        // 2、验证登录
        User login = userService.login(user);
        if (login != null) {
            // 找到该用户信息
            // 跳回登录成功页面
            request.getRequestDispatcher("/pages/user/login_success.jsp").forward(request, response);
        } else if (!userService.existsUsername(username)) {
            // 账号不存在
            request.setAttribute("msg", "用户名不存在");
            request.getRequestDispatcher("/pages/user/login.jsp").forward(request, response);
        } else {
            // 账号存在，但还是找不到，说明密码错误
            // 1、将已经输入的信息还显示在输入框中，
            request.setAttribute("msg", "密码错误");
            request.setAttribute("username", username);
            // 2、返回登录页面
            request.getRequestDispatcher("/pages/user/login.jsp").forward(request, response);
        }
    }

    
    /**
     * 处理注册请求
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    protected void regist(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 1、获取请求参数
        String username = request.getParameter("username");
        String password = request.getParameter("password");
        String email = request.getParameter("email");
        String code = request.getParameter("code");

        // 2、验证验证码是否正确   【暂时先写死，认定为abcd，后边在提供动态验证码】
        if ("abcd".equalsIgnoreCase(code)) {
            // 验证码正确
            // 验证账户信息
            User user = new User(null, username, password, email);

            if (userService.existsUsername(username)) {
                // 该账号已存在，跳回注册页面【并把回显信息保存到request域中】
                request.setAttribute("msg", "该账号已存在！");
                request.setAttribute("email", email);
                request.getRequestDispatcher("/pages/user/regist.jsp").forward(request, response);
            } else {
                // 成功注册
                // 保存用户信息
                userService.registUser(user);
                // 跳转注册成功地址
                request.getRequestDispatcher("/pages/user/regist_success.jsp").forward(request, response);
            }

        } else {
            // 验证码错误，跳回注册页面【并把回显信息保存到request域中】
            request.setAttribute("msg", "验证码错误，请重新输入！");
            request.setAttribute("username", username);
            request.setAttribute("email", email);
            request.getRequestDispatcher("/pages/user/regist.jsp").forward(request, response);
        }
    }
}
```



还要给 login.jsp 添加隐藏域action ，和修改请求地址 

![image-20211112115327441](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112115327441.png)

给 regist.jsp 页面添加隐藏域 action， 和修改请求地址  

![image-20211112115358513](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112115358513.png)

### 13.2、优化代码二：

 使用反射优化大量 else if 代码

- **if-else 用于判断目标函数是要干啥**
- 通过获取隐藏域的action，【因为隐藏域不显示，不影响界面】
- 如果action=”login“  进入登录代码，调用登录方法
- 如果action=“regist”进入注册代码，调用注册方法

<font color='red'>这里直接用反射 代替if—else，防止有成百上千个方法，要写成百上千个if-else</font>

```java
// 获取到action的字符串的值
String action = request.getParameter("action");

        // 方式一：if - else判断调用哪个方法
//        if ("login".equals(action)) {
//            // 登录方法调用
//            login(request,response);
//        } else if ("regist".equals(action)) {
//            // 注册方法调用
//            regist(request, response);
//        }

        // 方式二：反射
        try {
            // 获取action 业务鉴别字符串，获取相应的业务方法反射对象
            // getDeclaredMethod(参数1，参数2)
            // 参数1：指明获取的方法名字
            // 参数2：指明获取的方法的【形参列表的类的class类对象】
            Method method = this.getClass().getDeclaredMethod(action,HttpServletRequest.class,HttpServletResponse.class);
            // 调用目标方法
            method.invoke(this,request,response);
        } catch (Exception e) {
            e.printStackTrace();
        }
```



### 13.3、代码优化三： 

抽取 BaseServlet 程序

![image-20211112115922879](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112115922879.png)



**BaseServlet 程序代码：**

```java
public abstract class BaseServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String action = request.getParameter("action");

        try {
            // 获取action 业务鉴别字符串，获取相应的业务方法反射对象
            // getDeclaredMethod(参数1，参数2)
            // 参数1：指明获取的方法名字
            // 参数2：指明获取的方法的【形参列表的类的class类对象】
            Method method = this.getClass().getDeclaredMethod(action,HttpServletRequest.class,HttpServletResponse.class);
            // 调用目标方法
            method.invoke(this,request,response);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

修改 UserServlet 程序继承 BaseServlet 程序。  

![image-20211112120038690](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211112120038690.png)



## 14、数据的封装和抽取 BeanUtils 的使用

- BeanUtils 工具类， 它可以一次性的把所有请求的参数注入到 JavaBean 中。

	- 【就是如果自己new一个对象，new 构造器（参数1，参数2，参数3.......）】
	- 调用这个jar包中的populate() 方法后，一条代码解决，还能通用

- BeanUtils 工具类， 经常用于把 Map 中的值注入到 JavaBean 中， 或者是对象属性值的拷贝操作。

- BeanUtils 它不是 Jdk 的类。 而是第三方的工具类。 所以需要导包。

- 1、 导入需要的 jar 包：

	- commons-beanutils-1.8.0.jar
	- commons-logging-1.1.1.jar

- 2、 编写 WebUtils 工具类使用：

	

WebUtils 工具类：  

```java
public class WebUtils {
    /**
     * 把Map中的值注入到对应的JavaBean属性
     * @param value
     * @param bean
     */
    public static <T>T copyParamToBean(Map value, T bean){
        try {
            // 把对象的参数 注入到 bean对象中
            BeanUtils.populate(bean,value);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return bean;
    }
}
```

调用：

```java
原方法：
        String username = request.getParameter("username");
        String password = request.getParameter("password");
    	User user = new User(null, username, password, null);
		//【用下边的jar包工具类代替了这行代码】

新方法：
		User user = WebUtils.copyParamToBean(request.getParameterMap(), new User());
											【这里传的是map，方便其他类想调用时也传map就行了】

```





##  15、编写图书模块

### 一、编写图书模块的数据库表

```sql
-- 判断books数据库是否存在，存在就删除
drop table if exists t_book;


-- 图书模块初始表
create table t_book(
		`id` int primary key auto_increment,    -- 序列
		`name` varchar(50),											-- 书名
		`price` decimal(11,2),									-- 价格
		`author` varchar(50),										-- 作者
		`sales` int,														-- 销量
		`stock` int,														-- 库存
		`img_path` varchar(200)									-- 图书照片
);






## 插入初始化测试数据
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'java从入门到放弃' , '国哥' , 80 , 9999 , 9 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '数据结构与算法' , '严敏君' , 78.5 , 6 , 13 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '怎样拐跑别人的媳妇' , '龙伍' , 68, 99999 , 52 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '木虚肉盖饭' , '小胖' , 16, 1000 , 50 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'C++编程思想' , '刚哥' , 45.5 , 14 , 95 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '蛋炒饭' , '周星星' , 9.9, 12 , 53 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '赌神' , '龙伍' , 66.5, 125 , 535 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'Java编程思想' , '阳哥' , 99.5 , 47 , 36 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'JavaScript从入门到精通' , '婷姐' , 9.9 , 85 , 95 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'cocos2d-x游戏编程入门' , '国哥' , 49, 52 , 62 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'C语言程序设计' , '谭浩强' , 28 , 52 , 74 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'Lua语言程序设计' , '雷丰阳' , 51.5 , 48 , 82 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '西游记' , '罗贯中' , 12, 19 , 9999 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '水浒传' , '华仔' , 33.05 , 22 , 88 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '操作系统原理' , '刘优' , 133.05 , 122 , 188 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '数据结构 java版' , '封大神' , 173.15 , 21 , 81 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'UNIX高级环境编程' , '乐天' , 99.15 , 210 , 810 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'javaScript高级编程' , '国哥' , 69.15 , 210 , 810 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '大话设计模式' , '国哥' , 89.15 , 20 , 10 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '人月神话' , '刚哥' , 88.15 , 20 , 80 , 'static/img/default.jpg');
 


## 查看表内容
select id,name,author,price,sales,stock,img_path from t_book;




```



### 二、编写图书模块的 JavaBean

```java
package com.tianhao.bean;

import java.math.BigDecimal;

/**
 * @ClassName Book
 * @Description TODO:图书JavaBean
 * @Author sth_199509@163.com
 * @Date 2021/11/12 16:24
 * @Version 1.0
 */
public class Book {
    // Fields
    /**
     *      `id` int primary key auto_increment,    -- 序列
     *        `name` varchar(50),                                  -- 书名
     *        `price` decimal(11,2),                         -- 价格
     *        `author` varchar(50),                             -- 作者
     *        `sales` int,                                          -- 销量
     *        `stock` int,                                          -- 库存
     *        `img_path` varchar(200)                            -- 图书照片
     */
    private Integer id;
    private String name;
    private String author;
    private BigDecimal price;
    private Integer sales;
    private Integer stock;
    private String img_path = "static/img/default.jpg";

    // Constructors
    public Book() {}
    public Book(Integer id, String name, String author, BigDecimal price, Integer sales, Integer stock, String img_path) {
        this.id = id;
        this.name = name;
        this.author = author;
        this.price = price;
        this.sales = sales;
        this.stock = stock;
        this.img_path = img_path;
    }

    // Methods
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    public Integer getSales() {
        return sales;
    }

    public void setSales(Integer sales) {
        this.sales = sales;
    }

    public Integer getStock() {
        return stock;
    }

    public void setStock(Integer stock) {
        this.stock = stock;
    }

    public String getImg_path() {
        return img_path;
    }

    public void setImg_path(String img_path) {
        this.img_path = img_path;
    }

    @Override
    public String toString() {
        return "Book{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", author='" + author + '\'' +
                ", price=" + price +
                ", sales=" + sales +
                ", stock=" + stock +
                ", img_path='" + img_path + '\'' +
                '}';
    }
}
```



### 三、编写图书模块的 Dao 和测试 Dao

**BookDao 接口：**

```java
package com.tianhao.dao;

import com.tianhao.bean.Book;

import java.util.List;

/**
 * @ClassName BookDao
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/12 16:38
 * @Version 1.0
 */
public interface BookDao {
    /**
     * 添加图书
     * @param book
     * @return
     */
    int addBook(Book book);

    /**
     * 根据ID删除图书
     * @param id
     * @return
     */
    int deleteBookById(Integer id);

    /**
     * 更改图书信息
     * @param book
     * @return
     */
    int updateBook(Book book);

    /**
     * 根据ID查找图书
     * @param id
     * @return
     */
    Book queryBookById(Integer id);

    /**
     * 查询所有图书
     * @return
     */
    List<Book> queryBooks();
}
```



**BookDaoImpl类   实现BookDao接口：**

```java
package com.tianhao.dao.impl;

import com.tianhao.bean.Book;
import com.tianhao.dao.BookDao;

import java.util.List;

/**
 * @ClassName BookDaoImpl
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/12 16:45
 * @Version 1.0
 */
public class BookDaoImpl extends BaseDao implements BookDao {
    @Override
    public int addBook(Book book) {
        String sql = "insert into t_book(`name`,`author`,`price`,`sales`,`stock`,`img_path`)values(?,?,?,?,?,?)";
        return update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImg_path());
    }

    @Override
    public int deleteBookById(Integer id) {
        String sql = "delete from t_book where id=?";
        return update(sql,id);
    }

    @Override
    public int updateBook(Book book) {
        String sql = "update t_book set `name`=?,`author`=?,`price`=?,`sales`=?,`stock`=?,`img_path`=? where `id`=?";
        return update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImg_path(),book.getId());
    }

    @Override
    public Book queryBookById(Integer id) {
        String sql = "select * from t_book where `id`=?";
        return queryForOne(Book.class,sql,id);
    }

    @Override
    public List<Book> queryBooks() {
        String sql = "select * from t_book";
        return queryForList(Book.class,sql);
    }
}
```



BookDaoImplTest类			测试BookDaoImpl类

```java
package com.tianhao.dao.impl;

import com.tianhao.bean.Book;
import com.tianhao.dao.BookDao;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.List;


/**
 * @ClassName BookDaoImplTest
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/12 17:04
 * @Version 1.0
 */
class BookDaoImplTest {
    private BookDao bookDao = new BookDaoImpl();
    @Test
    void addBook() {
        Book onehundred = new Book(null,"百年孤独", "加西亚·马尔克斯", new BigDecimal(99),10000,89898,"static/img/onehundred.png");
        int i = bookDao.addBook(onehundred);
        System.out.println(i);
    }

    @Test
    void deleteBookById() {
        int i = bookDao.deleteBookById(3);
        System.out.println(i);
    }

    @Test
    void updateBook() {
        Book onehundred = new Book(21,"百年孤独", "加西亚·马尔克斯", new BigDecimal(99),9,899,"static/img/onehundred.png");
        int i = bookDao.updateBook(onehundred);
        System.out.println(i);
    }

    @Test
    void queryBookById() {
        Book book = bookDao.queryBookById(5);
        System.out.println(book);
    }

    @Test
    void queryBooks() {
        List<Book> books = bookDao.queryBooks();
        books.forEach(System.out::println);
    }
}
```





### 四、编写图书模块的 Service 和测试 Service

**BookService接口：**

```java
package com.tianhao.service;

import com.tianhao.bean.Book;

import java.util.List;

/**
 * @ClassName BookService
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/12 17:32
 * @Version 1.0
 */
public interface BookService {
    /**
     * 添加图书
     * @param book
     * @return
     */
    void addBook(Book book);

    /**
     * 根据ID删除图书
     * @param id
     * @return
     */
    void deleteBookById(Integer id);

    /**
     * 更改图书信息
     * @param book
     * @return
     */
    void updateBook(Book book);

    /**
     * 根据ID查找图书
     * @param id
     * @return
     */
    Book queryBookById(Integer id);

    /**
     * 查询所有图书
     * @return
     */
    List<Book> queryBooks();
}
```



**BookServiceImpl类 ，实现BookService接口：**

```java
package com.tianhao.service.impl;

import com.tianhao.bean.Book;
import com.tianhao.dao.BookDao;
import com.tianhao.dao.impl.BookDaoImpl;
import com.tianhao.service.BookService;

import java.util.List;

/**
 * @ClassName BookServiceImpl
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/12 17:33
 * @Version 1.0
 */
public class BookServiceImpl implements BookService {
    private BookDao bookDao = new BookDaoImpl();
    @Override
    public void addBook(Book book) {
        bookDao.addBook(book);
    }

    @Override
    public void deleteBookById(Integer id) {
        bookDao.deleteBookById(id);
    }

    @Override
    public void updateBook(Book book) {
        bookDao.updateBook(book);
    }

    @Override
    public Book queryBookById(Integer id) {
        return bookDao.queryBookById(id);
    }

    @Override
    public List<Book> queryBooks() {
        return bookDao.queryBooks();
    }
}
```

**BookServiceImplTest类，BookServiceImpl的测试类：**

```java
package com.tianhao.service.impl;

import com.tianhao.bean.Book;
import com.tianhao.service.BookService;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * @ClassName BookServiceImplTest
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/12 17:36
 * @Version 1.0
 */
class BookServiceImplTest {
    BookService bookService = new BookServiceImpl();
    @Test
    void addBook() {
        Book fortressBesieged = new Book(null,"围城", "钱钟书", new BigDecimal(100),100,88,"static/img/fortressbesieged.png");
        bookService.addBook(fortressBesieged);
    }

    @Test
    void deleteBookById() {
        bookService.deleteBookById(6);
    }

    @Test
    void updateBook() {
        Book sixChapters = new Book(4,"浮生六记", "沈复", new BigDecimal(88),155,77,"static/img/sixchapters.png");
        bookService.updateBook(sixChapters);
    }

    @Test
    void queryBookById() {
        Book book = bookService.queryBookById(4);
        System.out.println(book);
    }

    @Test
    void queryBooks() {
        List<Book> books = bookService.queryBooks();
        books.forEach(System.out::println);
    }
}
```



### 五、编写图书模块的 Web 层， 和页面联调测试

#### 1、图书列表功能的实现  

图解：

![image-20211113211742581](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113211742581.png)

- BookServlet 程序中添加 list 方法


```java
protected void list(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 1、通过BookService 查询全部图书
    List<Book> books = bookService.queryBooks();
    // 2、把全部图书信息保存早Request域中
    request.setAttribute("books",books);
    // 3、请求转发到/pages/manager/book_manager.jsp页面
    request.getRequestDispatcher("/pages/manager/book_manager.jsp").forward(request,response);
}
```

- 修改【图书管理】 请求地址

	```java
	<%@ page contentType="text/html;charset=UTF-8" language="java" %>
	<div>
	<%--    <a href="pages/manager/book_manager.jsp">图书管理</a>--%>
	    <a href="manager/bookServlet?action=list">图书管理</a>
	    <a href="pages/manager/order_manager.jsp">订单管理</a>
	    <a href="index.jsp">返回商城</a>
	</div>
	```

- 修改 pages/manager/book_manager.jsp 页面的数据遍历输出

	```jsp
	<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
	<%@ page contentType="text/html;charset=UTF-8" language="java" %>
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>图书管理</title>
	   <%--静态包含 base标签、css样式、jQuery文件--%>
	   <%@ include file="/pages/common/head.jsp"%>
	
	   <script type="text/javascript">
	      $(function () {// 页面加载之后
	         // 给删除的a标签绑定单击事件，就是让你确认一下，别删错了
	         $("a.deleteClass").click(function () {
	
	            // 在事件的function函数中，有一个this对象
	            // 这个this对象   是当前正在响应事件的dom对象【此处表示删除行的a标签对象】
	
	            /**
	             * confirm 是确认提示框函数
	             * 参数是他的提示内容
	             * 他有两个按钮，一个确认，一个取消
	             * 点击确认：返回true
	             * 点击取消：返回false
	             *
	             */
	            // 直接return就行了
	            // 如果返回true  页面继续向下执行
	            // 如果返回false 阻止页面继续向下执行，也就没有删除，不提交请求
	            return confirm("你确定要删除《" + $(this).parent().parent().find("td:first").text() + "》吗？");
	            // 当前是a标签，找一次父类，到td再父类到tr，在tr中找第一个td就是name标签
	         })
	      });
	
	   </script>
	</head>
	<body>
	   
	   <div id="header">
	         <img class="logo_img" alt="" src="static/img/logo.gif" >
	         <span class="wel_word">图书管理系统</span>
	
	         <%--静态包含 引入管理页面的菜单       --%>
	         <%@include file="/pages/common/manager_menu.jsp"%>
	
	   </div>
	   
	   <div id="main">
	      <table>
	         <tr>
	            <td>名称</td>
	            <td>价格</td>
	            <td>作者</td>
	            <td>销量</td>
	            <td>库存</td>
	            <td colspan="2">操作</td>
	         </tr>
	         <c:forEach items="${requestScope.books}" var="book">
	            <tr >
	               <td>${book.name}</td>
	               <td>${book.price}</td>
	               <td>${book.author}</td>
	               <td>${book.sales}</td>
	               <td>${book.stock}</td>
	<%--               <td><a href="manager/bookServlet?action=getBook&id=${book.id}"&method=update>修改</a></td>--%>
	               <td><a href="manager/bookServlet?action=getBook&id=${book.id}">修改</a></td>
	               <td><a class="deleteClass" href="manager/bookServlet?action=delete&id=${book.id}">删除</a></td>
	            </tr>
	         </c:forEach>
	         <tr>
	            <td></td>
	            <td></td>
	            <td></td>
	            <td></td>
	            <td></td>
	            <td></td>
	<%--            <td><a href="pages/manager/book_edit.jsp"&method="add">添加图书</a></td>--%>
	            <td><a href="pages/manager/book_edit.jsp">添加图书</a></td>
	         </tr>
	      </table>
	   </div>
	
	
	   <%--静态包含，页脚信息  --%>
	   <%@include file="/pages/common/footer.jsp"%>
	
	</body>
	</html>
	```

- 主要循环代码

	```jsp
	         <c:forEach items="${requestScope.books}" var="book">
	            <tr >
	               <td>${book.name}</td>
	               <td>${book.price}</td>
	               <td>${book.author}</td>
	               <td>${book.sales}</td>
	               <td>${book.stock}</td>
	<%--               <td><a href="manager/bookServlet?action=getBook&id=${book.id}"&method=update>修改</a></td>--%>
	               <td><a href="manager/bookServlet?action=getBook&id=${book.id}">修改</a></td>
	               <td><a class="deleteClass" href="manager/bookServlet?action=delete&id=${book.id}">删除</a></td>
	            </tr>
	         </c:forEach>
	```

#### 2、前后台的简单介绍

![image-20211113212305418](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113212305418.png)

#### 3、添加图书功能的实现

##### 3.1、添加图书流程细节：

![image-20211113212432750](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113212432750.png)

##### 3.2、问题说明： 表单重复提交：

当用户提交完请求， 浏览器会记录下最后一次请求的全部信息。 当用户按下功能键 F5， 就会发起浏览器记录的最后一次请求。  

- 使用请求转发**【这时所有操作归为一次请求】【如果用户刷新页面，会造成表单重复提交】**
	- request.getRequestDispatcher("/manager/bookServlet?action=list").forward(request,response);
- 应该使用请求重定向**【重定向后，就是两次请求，刷新只会重新提交当前页面，之前添加图书操作已经是过去式了】**
	- 重定向默认地址是：Http://localhost:8080   所以要加上工程名
		      【请求转发因为是一次请求，所以地址定位在当前工程下】
	- response.sendRedirect(request.getContextPath() + "/manager/bookServlet?action=list");

```java
// 3、跳回图书管理页面
        // 使用请求转发【这时所有操作归为一次请求】【如果用户刷新页面，会造成表单重复提交】
//        request.getRequestDispatcher("/manager/bookServlet?action=list").forward(request,response);
        // 应该使用请求重定向【重定向后，就是两次请求，刷新只会重新提交当前页面，之前添加图书操作已经是过去式了】
        //System.out.println(request.getContextPath());//    获取工程名/Books
        // 重定向默认地址是：Http://localhost:8080   所以要加上工程名
        // 【请求转发因为是一次请求，所以地址定位在当前工程下】
        response.sendRedirect(request.getContextPath() + "/manager/bookServlet?action=list");
```



##### 3.3、BookServlet 程序中添加 add 方法

```java
protected void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 1、获取请求的参数   封装成Book对象
        Book book = WebUtils.copyParamToBean(request.getParameterMap(), new Book());
        // 2、调用BookService.addBook() 保存图书
        bookService.addBook(book);
        // 3、跳回图书管理页面
        // 使用请求转发【这时所有操作归为一次请求】【如果用户刷新页面，会造成表单重复提交】
//        request.getRequestDispatcher("/manager/bookServlet?action=list").forward(request,response);
        // 应该使用请求重定向【重定向后，就是两次请求，刷新只会重新提交当前页面，之前添加图书操作已经是过去式了】
        //System.out.println(request.getContextPath());//    获取工程名/Books
        // 重定向默认地址是：Http://localhost:8080   所以要加上工程名
        // 【请求转发因为是一次请求，所以地址定位在当前工程下】
        response.sendRedirect(request.getContextPath() + "/manager/bookServlet?action=list");
    }
```

##### 3.4、修改 book_edit.jsp 页面

```java
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>编辑图书</title>
   <%--静态包含 base标签、css样式、jQuery文件--%>
   <%@ include file="/pages/common/head.jsp"%>

   <style type="text/css">
   h1 {
      text-align: center;
      margin-top: 200px;
   }
   
   h1 a {
      color:red;
   }
   
   input {
      text-align: center;
   }
</style>
</head>
<body>
      <div id="header">
         <img class="logo_img" alt="" src="static/img/logo.gif" >
         <span class="wel_word">编辑图书</span>

         <%--静态包含 引入管理页面的菜单       --%>
         <%@include file="/pages/common/manager_menu.jsp"%>

      </div>
      
      <div id="main">
         <form action="manager/bookServlet" method="post">
<%--            实现动态调整隐藏域的value值，判断是添加操作，还是修改操作--%>
<%--            方式一：在添加或修改提交按钮处，增加一个参数&method=update/add--%>
<%--            在隐藏域中获取该值--%>
<%--            <input type="hidden" name="action" value="${param.method}"/>--%>
<%--            方式二：通过判断是否有id这个参数，因为修改要用到查询带了个id参数，但是添加没有--%>
<%--            若空：则表示添加，--%>
<%--            不空：则表示修改。--%>
            <input type="hidden" name="action" value="${empty param.id ? "add":"update"}"/>
<%--            因为修改操作需要查询，所以需要原id--%>
            <input type="hidden" name="id" value="${requestScope.book.id}"/>
<%--            因为传回去的图书信息，没有id，但是update要查询修改的图书通过id，所以这里封装一个--%>
<%--            因为request.getParameterMap()会获取所有的键值对，所以这里弄一个隐藏域键值，那边不用管，自动就能获取到--%>
<%--            但是名字一定要对，要不然没办法封装--%>

            <table>
               <tr>
                  <td>名称</td>
                  <td>价格</td>
                  <td>作者</td>
                  <td>销量</td>
                  <td>库存</td>
                  <td colspan="2">操作</td>
               </tr>     
               <tr>
                  <td><input name="name" type="text" value="${requestScope.book.name}"/></td>
                  <td><input name="price" type="text" value="${requestScope.book.price}"/></td>
                  <td><input name="author" type="text" value="${requestScope.book.author}"/></td>
                  <td><input name="sales" type="text" value="${requestScope.book.sales}"/></td>
                  <td><input name="stock" type="text" value="${requestScope.book.stock}"/></td>
                  <td><input type="submit" value="提交"/></td>
               </tr>  
            </table>
         </form>
         
   
      </div>


      <%--静态包含，页脚信息  --%>
      <%@include file="/pages/common/footer.jsp"%>


</body>
</html>
```



#### 4、删除图书功能的实现

##### 4.1、图解删除流程：  

![image-20211113212945246](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113212945246.png)



##### 4.2、BookServlet 程序中的 delete 方法

```java
protected void delete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 1、获取请求的参数   要删除的id
    int id = WebUtils.parseInt(request.getParameter("id"),0);
    // 2、调用BookService.deleteBookById()   通过id删除图书
    bookService.deleteBookById(id);
    // 3、跳回图书管理页面
    response.sendRedirect(request.getContextPath() + "/manager/bookServlet?action=list");
}
```

##### 4.3、给 WebUtils 工具类添加转换 int 类型的工具方法

```java
/**
 * 将字符串转换成int类型的数据
 * 主要统一写，减少重复代码， 因为这个过程要处理异常，代码比较啰嗦
 * @param str
 * @param defaultValue
 * @return
 */
public static int parseInt(String str,int defaultValue){
    try {
        return Integer.parseInt(str);
    } catch (NumberFormatException e) {
        e.printStackTrace();
    }
    return defaultValue;
}
```

##### 4.4、修改删除的连接地址：

因为删除要用到id，所以将当前dom对象的id通过el表达式传过去

```jsp
<a class="deleteClass" href="manager/bookServlet?action=delete&id=${book.id}">删除</a>
```

##### 4.5、给删除添加确认提示操作：

- 给删除的a标签绑定单击事件，就是让你确认一下，别删错了、

	

```jsp
<script type="text/javascript">
   $(function () {// 页面加载之后
      // 给删除的a标签绑定单击事件，就是让你确认一下，别删错了
      $("a.deleteClass").click(function () {

         // 在事件的function函数中，有一个this对象
         // 这个this对象   是当前正在响应事件的dom对象【此处表示删除行的a标签对象】

         /**
          * confirm 是确认提示框函数
          * 参数是他的提示内容
          * 他有两个按钮，一个确认，一个取消
          * 点击确认：返回true
          * 点击取消：返回false
          *
          */
         // 直接return就行了
         // 如果返回true  页面继续向下执行
         // 如果返回false 阻止页面继续向下执行，也就没有删除，不提交请求
         return confirm("你确定要删除《" + $(this).parent().parent().find("td:first").text() + "》吗？");
         // 当前是a标签，找一次父类，到td再父类到tr，在tr中找第一个td就是name标签
      })
   });

</script>
```

#### 5、修改图书功能的实现

##### 5.1、图解修改图书细节：  

<img src="https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113224110197.png" alt="image-20211113213749241" style="zoom:150%;" />

##### 5.2、 更新【修改】 的请求地址

此处因为add操作和update操作，都要用到图书管理页面，所以要区分是什么操作

```jsp
方式一：直接传参本次操作是修改
<%--<td><a href="manager/bookServlet?action=getBook&id=${book.id}"&method=update>修改</a></td>--%>

方式二：修改有id，添加没有，判断是不是有id值
<td><a href="manager/bookServlet?action=getBook&id=${book.id}">修改</a></td>
```

##### 5.3、 BookServlet 程序中添加 getBook 方法：  

```java
protected void getBook(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 1、获取请求参数   获取要修改的图书id信息
    int id = WebUtils.parseInt(request.getParameter("id"),0);
    // 2、查询图书信息
    Book book = bookService.queryBookById(id);
    // 3、把图书保存早Request域中
    request.setAttribute("book",book);// 第一个book是起的名字，第二个时Book对象
    // 4、请求转发到图书编辑页面
    request.getRequestDispatcher("/pages/manager/book_edit.jsp").forward(request,response);

}
```

##### 5.4、 在 book_edit.jsp 页面中显示修改的数据

此处修改默认value值，因为修改，肯定默认显示你要修改的图书信息，然后供你修改

getBook()已经把查询到的图书信息保存到Request域中，这边直接读取

value="${requestScope.book.name}"

```jsp
<tr>
    <td><input name="name" type="text" value="${requestScope.book.name}"/></td>
    <td><input name="price" type="text" value="${requestScope.book.price}"/></td>
    <td><input name="author" type="text" value="${requestScope.book.author}"/></td>
    <td><input name="sales" type="text" value="${requestScope.book.sales}"/></td>
    <td><input name="stock" type="text" value="${requestScope.book.stock}"/></td>
    <td><input type="submit" value="提交"/></td>
</tr>	
```



##### 5.5、在 BookServlet 程序中添加 update 方法：  

```java
protected void update(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 1、获取请求的参数   封装成Book对象
    Book book = WebUtils.copyParamToBean(request.getParameterMap(), new Book());
    // 2、调用BookService.updateBook() 修改并保存图书
    bookService.updateBook(book);
    // 3、跳回图书管理页面
    response.sendRedirect(request.getContextPath() + "/manager/bookServlet?action=list");
}
```

##### 5.6、 解决 book_edit.jsp 页面， 即要实现添加， 又要实现修改操作。

实现动态调整隐藏域的value值，判断是添加操作，还是修改操作

- 方式一：在添加或修改提交按钮处，增加一个参数&method=update/add
	- 在隐藏域中获取该值
- 方式二：通过判断是否有id这个参数，因为修改要用到查询带了个id参数，但是添加没有
	- 若空：则表示添加，
	- 不空：则表示修改。

```jsp
<form action="manager/bookServlet" method="post">

	方式一：
    <input type="hidden" name="action" value="${param.method}"/>
    方式二：
    <input type="hidden" name="action" value="${empty param.id ? "add":"update"}"/>
<%--            因为修改操作需要查询，所以需要原id--%>
            <input type="hidden" name="id" value="${requestScope.book.id}"/>
<%--            因为传回去的图书信息，没有id，但是update要查询修改的图书通过id，所以这里封装一个--%>
<%--            因为request.getParameterMap()会获取所有的键值对，所以这里弄一个隐藏域键值，那边不用管，自动就能获取到--%>
<%--            但是名字一定要对，要不然没办法封装--%>

            <table>
```

- 因为修改操作需要查询，所以需要原id
- ​            <input type="hidden" name="id" value="${requestScope.book.id}"/>
- 因为传回去的图书信息，没有id，但是update要查询修改的图书通过id，所以这里封装一个
- 因为request.getParameterMap()会获取所有的键值对，所以这里弄一个隐藏域键值，那边不用管，自动就能获取到,但是名字一定要对，要不然没办法封装--%>



## 16、图书分页

### 一、分页模块的分析

![image-20211113223118846](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113213749241.png)



### 二、分页模型 Page 的抽取

- （当前页数， 总页数， 总记录数，当前页数据， 每页记录数）  

```java
/**
 * @ClassName Page
 * @Description TODO:分页模块
 * page是分页的模型对象
 * <T>是具体的模块的JavaBean【就是可以对任何页面，套用此分页模块，只要更换不同的对象就行了】
 * @Author sth_199509@163.com
 * @Date 2021/11/14 21:38
 * @Version 1.0
 */
public class Page<T> {
    // Fields
    // 每页显式数据条数
    public static final Integer PAGE_SIZE = 4;
    // 当前页码
    private Integer pageNo;
    // 总页码数
    private Integer pageTotal;
    // 当前页显式数量
    private Integer pageSize = PAGE_SIZE;
    // 总记录数
    private Integer pageTotalCount;
    // 当前页面数据
    private List<T> items;
    // 请求地址
    String url;
```





### 三、分页的初步实现

BookDao 代码：

```java
    @Override
    public Integer queryForPageTotalCount() {
        String sql = "select count(*) from t_book";
        Number value = (Number) queryForSingleValue(sql);// 返回值只能是long或者Number类型
        return value.intValue();
    }

    @Override
    public List<Book> queryForPageItems(int begin, int pageSize) {
        String sql = "select * from t_book limit ?,?";
        return queryForList(Book.class,sql,begin,pageSize);
    }

    @Override
    public Integer queryForPriceTotalCount(int min,int max) {
        String sql = "select count(*) from t_book where `price` > ? and `price` < ?";
//        String sql = "select count(*) from t_book where `price` between ? and ?";
        Number count = (Number)queryForSingleValue(sql, min, max);
        return count.intValue();
    }

    @Override
    public List<Book> queryForPricePageItems(int begin, int pageSize, int min, int max) {
        String sql = "select * from t_book where `price` between ? and ? order by `price` limit ?,?";
        return queryForList(Book.class,sql,min,max,begin,pageSize);
    }
```

BookService 代码：

```java
@Override
public Page<Book> page(int pageNo, int pageSize) {
    Page<Book> page = new Page<>();
    // 每页展示数量
    page.setPageSize(pageSize);
    // 总记录数
    Integer pageTotalCount = bookDao.queryForPageTotalCount();
    page.setPageTotalCount(pageTotalCount);
    // 总页数【如果不是整除，证明页面放不下，在后面追加一个页面】
    page.setPageTotal(pageTotalCount % pageSize > 0 ? pageTotalCount/pageSize + 1 : pageTotalCount/pageSize);

    // 当前页码
    page.setPageNo(pageNo);//【因为，setPageNo方法，要用到pageTotal总页数属性，所以先设置总页数，在设置当前页】

    // 当前页面展示内容
    int begin = (page.getPageNo() - 1) * pageSize; // 因为setPageNo()方法有可能重置pageNo的值，所以用get方法，不用直接传的参数
    // 【索引开始值，假设每页4个，第3页开始第一个索引就是2*4】
    List<Book> booksItems = bookDao.queryForPageItems(begin,pageSize);
    page.setItems(booksItems);


    return page;
}

@Override
public Page<Book> pageByPrice(int pageNo, int pageSize,int min,int max) {
    Page<Book> page = new Page<>();
    // 每页展示数量
    page.setPageSize(pageSize);
    // 总记录数
    Integer pagePriceTotalCount = bookDao.queryForPriceTotalCount(min,max);
    page.setPageTotalCount(pagePriceTotalCount);
    // 总页数【如果不是整除，证明页面放不下，在后面追加一个页面】
    page.setPageTotal(pagePriceTotalCount % pageSize > 0 ? pagePriceTotalCount/pageSize + 1 : pagePriceTotalCount/pageSize);

    // 当前页码
    page.setPageNo(pageNo);//【因为，setPageNo方法，要用到pageTotal总页数属性，所以先设置总页数，在设置当前页】

    // 当前页面展示内容
    int begin = (page.getPageNo() - 1) * pageSize; // 因为setPageNo()方法有可能重置pageNo的值，所以用get方法，不用直接传的参数
    // 【索引开始值，假设每页4个，第3页开始第一个索引就是2*4】
    List<Book> booksItems = bookDao.queryForPricePageItems(begin,pageSize,min,max);
    page.setItems(booksItems);
    return page;
}
```

BookServlet 程序的代码：

```java
/**
 * 处理分页功能
 *
 * @param request
 * @param response
 * @throws ServletException
 * @throws IOException
 */
protected void page(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 1、获取请求参数 pageNo 和 pageSize【直接转换成整型】
    int pageNo = WebUtils.parseInt(request.getParameter("pageNo"), 1);
    int pageSize = WebUtils.parseInt(request.getParameter("pageSize"), Page.PAGE_SIZE);
    // 2、调用BookService.page(pageNo,pageSize)方法，返回Page对象
    Page<Book> page = bookService.page(pageNo,pageSize);
    page.setUrl("manager/bookServlet?action=page");
    // 3、保存Page对象到Request 域中
    request.setAttribute("page",page);
    // 4、请求转发到pages/manager/book_manager.jsp
    // !!!!!!请求转发别忘了.forward(request,response)
    request.getRequestDispatcher("/pages/manager/book_manager.jsp").forward(request,response);
}
```

manager_menu.jsp 中【图书管理】 请求地址的修改：

![image-20211115093931377](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211115093931377.png)

book_manager.jsp 修改：

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>图书管理</title>
   <%--静态包含 base标签、css样式、jQuery文件--%>
   <%@ include file="/pages/common/head.jsp"%>

   <script type="text/javascript">
      $(function () {// 页面加载之后
         // 给删除的a标签绑定单击事件，就是让你确认一下，别删错了
         $("a.deleteClass").click(function () {

            // 在事件的function函数中，有一个this对象
            // 这个this对象   是当前正在响应事件的dom对象【此处表示删除行的a标签对象】

            /**
             * confirm 是确认提示框函数
             * 参数是他的提示内容
             * 他有两个按钮，一个确认，一个取消
             * 点击确认：返回true
             * 点击取消：返回false
             *
             */
            // 直接return就行了
            // 如果返回true  页面继续向下执行
            // 如果返回false 阻止页面继续向下执行，也就没有删除，不提交请求
            return confirm("你确定要删除《" + $(this).parent().parent().find("td:first").text() + "》吗？");
            // 当前是a标签，找一次父类，到td再父类到tr，在tr中找第一个td就是name标签
         });
         // 跳转到指定的页码
         $("#searchPageBtn").click(function () {
            var pageTo = $("#pn_input").val();
            /**
             * javaScript 语言中提供了一个location 【地址栏对象】
             * 他有一个属性叫href  他可以获取浏览器地址栏中的地址
             * href属性可读可写，写的话直接就跳转过去了
             */
            // 总页码数
            var pageTotal = ${requestScope.page.pageTotal};
            // 判断输入页面是否非法【这里还要去BookServiceImpl中设置，防止用户直接在地址栏输入，非法页面】
            if (pageTo > 0 && pageTo <= pageTotal){
               // 这不要确认head.jsp中有pageContext.setAttribute("basePath",basePath);
               location.href = "${pageScope.basePath}manager/bookServlet?action=page&pageNo=" + pageTo;
            }else{
               return confirm("输入页码有误，请输入正确页码");
            }
         });

      });

   </script>
</head>
<body>
   
   <div id="header">
         <img class="logo_img" alt="" src="static/img/logo.gif" >
         <span class="wel_word">图书管理系统</span>

         <%--静态包含 引入管理页面的菜单       --%>
         <%@include file="/pages/common/manager_menu.jsp"%>

   </div>
   
   <div id="main">
      <table>
         <tr>
            <td>名称</td>
            <td>价格</td>
            <td>作者</td>
            <td>销量</td>
            <td>库存</td>
            <td colspan="2">操作</td>
         </tr>
         <c:forEach items="${requestScope.page.items}" var="book">
            <tr >
               <td>${book.name}</td>
               <td>${book.price}</td>
               <td>${book.author}</td>
               <td>${book.sales}</td>
               <td>${book.stock}</td>
<%--               <td><a href="manager/bookServlet?action=getBook&id=${book.id}"&method=update>修改</a></td>--%>
               <td><a href="manager/bookServlet?action=getBook&id=${book.id}&pageNo=${requestScope.page.pageNo}">修改</a></td>
               <td><a class="deleteClass" href="manager/bookServlet?action=delete&id=${book.id}&pageNo=${requestScope.page.pageNo}">删除</a></td>
            </tr>
         </c:forEach>
         <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
<%--            <td><a href="pages/manager/book_edit.jsp"&method="add">添加图书</a></td>--%>
            <%--把总页数传过去，让添加完成后，能看到最后一页--%>
            <td><a href="pages/manager/book_edit.jsp?pageNo=${requestScope.page.pageTotal}">添加图书</a></td>
         </tr>
      </table>
      <%--静态包含分页条       --%>
      <%@include file="/pages/common/page_nav.jsp"%>
   </div>


   <%--静态包含，页脚信息  --%>
   <%@include file="/pages/common/footer.jsp"%>


</body>
</html>
```

### 四、首页、 上一页、 下一页、 末页实现

```jsp
<%--
  Created by IntelliJ IDEA.
  User: kingb
  Date: 2021/11/15
  Time: 8:03
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%--      分页条的开始--%>
<div id="page_nav">
    <%--当前页面大于1，才显示首页和上一页操作，要不然第一页你再上一页跑哪去了？？？？          --%>
    <c:if test="${requestScope.page.pageNo >1}">
        <a href="${requestScope.page.url}&pageNo=1">首页</a>
        <a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo - 1}">上一页</a>
    </c:if>

    <%--页码输出的开始--%>
    <c:choose>
        <%--情况 1： 如果总页码小于等于 5 的情况， 页码的范围是： 1-总页码--%>
        <c:when test="${ requestScope.page.pageTotal <= 5 }">
            <c:set var="begin" value="1"/>
            <c:set var="end" value="${requestScope.page.pageTotal}"/>
        </c:when>
        <%--情况 2： 总页码大于 5 的情况--%>
        <c:when test="${requestScope.page.pageTotal > 5}">
            <c:choose><%--小情况 1： 当前页码为前面 3 个： 1， 2， 3 的情况， 页码范围是： 1-5.--%>
                <c:when test="${requestScope.page.pageNo <= 3}">
                    <c:set var="begin" value="1"/>
                    <c:set var="end" value="5"/>
                </c:when>
                <%--小情况 2： 当前页码为最后 3 个， 8， 9， 10， 页码范围是： 总页码减 4 - 总页码--%>
                <c:when test="${requestScope.page.pageNo > requestScope.page.pageTotal-3}">
                    <c:set var="begin" value="${requestScope.page.pageTotal-4}"/>
                    <c:set var="end" value="${requestScope.page.pageTotal}"/>
                </c:when>
                <%--小情况 3： 4， 5， 6， 7， 页码范围是： 当前页码减 2 - 当前页码加 2--%>
                <c:otherwise>
                    <c:set var="begin" value="${requestScope.page.pageNo-2}"/>
                    <c:set var="end" value="${requestScope.page.pageNo+2}"/>
                </c:otherwise>
            </c:choose>
        </c:when>
    </c:choose>
    <c:forEach begin="${begin}" end="${end}" var="i">
        <c:if test="${i == requestScope.page.pageNo}">
            【${i}】
        </c:if>
        <c:if test="${i != requestScope.page.pageNo}">
            <a href="${requestScope.page.url}&pageNo=${i}">${i}</a>
        </c:if>
    </c:forEach>
    <%--页码输出的结束--%>


    <%--当前页面小于总页数，才显示末页和下一页操作，要不然最后一页你再下一页跑哪去了？？？？       --%>
    <c:if test="${requestScope.page.pageNo < requestScope.page.pageTotal}" >
        <a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo + 1}">下一页</a>
        <a href="${requestScope.page.url}&pageNo=${requestScope.page.pageTotal}">末页</a>
    </c:if>
    共${requestScope.page.pageTotal}页，${requestScope.page.pageTotalCount}条记录
    到第<input value="${param.pageNo == null ? 1 : param.pageNo }" name="pn" id="pn_input"/>页
    <input id="searchPageBtn" type="button" value="确定">

</div>
<%--      分页条的结束--%>
```



### 五、分页模块中跳转到指定页数功能实现  

```jsp
<script type="text/javascript">
		$(function () {// 页面加载之后
			
			// 跳转到指定的页码
			$("#searchPageBtn").click(function () {
				var pageTo = $("#pn_input").val();
				/**
				 * javaScript 语言中提供了一个location 【地址栏对象】
				 * 他有一个属性叫href  他可以获取浏览器地址栏中的地址
				 * href属性可读可写，写的话直接就跳转过去了
				 */
				// 总页码数
				var pageTotal = ${requestScope.page.pageTotal};
				// 判断输入页面是否非法【这里还要去BookServiceImpl中设置，防止用户直接在地址栏输入，非法页面】
				if (pageTo > 0 && pageTo <= pageTotal){
					// 这不要确认head.jsp中有pageContext.setAttribute("basePath",basePath);
					location.href = "${pageScope.basePath}manager/bookServlet?action=page&pageNo=" + pageTo;
				}else{
					return confirm("输入页码有误，请输入正确页码");
				}
			});

		});

	</script>
<div>    
共${requestScope.page.pageTotal}页，${requestScope.page.pageTotalCount}条记录
    到第<input value="${param.pageNo == null ? 1 : param.pageNo }" name="pn" id="pn_input"/>页
    <input id="searchPageBtn" type="button" value="确定">

</div>
```

Page 对象中的修改：  

```java
public void setPageNo(Integer pageNo) {
    // 数据边界的有效检查【这个代码要写在setPageSize后边，因为要用pageSize属性】
    /**
     * 方案：大于总页码，置为总页码
     * 小于第一页，置为第一页
     */
    if (pageNo < 1){
        this.pageNo = 1;
    }else if (pageNo > pageTotal){
        this.pageNo = pageTotal;
    }else{
        this.pageNo = pageNo;
    }
}
```

BookService 中 page 方法的修改：  

【因为，setPageNo方法，要用到pageTotal总页数属性，所以先设置总页数，再设置当前页】

```java
@Override
public Page<Book> page(int pageNo, int pageSize) {
    Page<Book> page = new Page<>();
    // 每页展示数量
    page.setPageSize(pageSize);
    // 总记录数
    Integer pageTotalCount = bookDao.queryForPageTotalCount();
    page.setPageTotalCount(pageTotalCount);
    // 总页数【如果不是整除，证明页面放不下，在后面追加一个页面】
    page.setPageTotal(pageTotalCount % pageSize > 0 ? pageTotalCount/pageSize + 1 : pageTotalCount/pageSize);

    // 当前页码
    page.setPageNo(pageNo);//【因为，setPageNo方法，要用到pageTotal总页数属性，所以先设置总页数，在设置当前页】

    // 当前页面展示内容
    int begin = (page.getPageNo() - 1) * pageSize; // 因为setPageNo()方法有可能重置pageNo的值，所以用get方法，不用直接传的参数
    // 【索引开始值，假设每页4个，第3页开始第一个索引就是2*4】
    List<Book> booksItems = bookDao.queryForPageItems(begin,pageSize);
    page.setItems(booksItems);


    return page;
}
```



### 六、页码 1,2,【3】 ,4,5 的显示， 

要显示 5 个页码， 并且页码可以点击跳转。  

**需求：** 显示 5 个连续的页码， 而且当前页码在中间。 除了当前页码之外， 每个页码都可以点击跳到指定页。  

- 情况 1： 如果总页码小于等于 5 的情况， 页码的范围是： 1-总页码  

![image-20211113224019790](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113224019790.png)

- 情况 2： 总页码大于 5 的情况。 假设一共 10 页

	- 小情况 1： 当前页码为前面 3 个： 1， 2， 3 的情况， 页码范围是： 1-5.  

		![image-20211113224110197](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113223118846.png)

	- 小情况 2： 当前页码为最后 3 个， 8， 9， 10， 页码范围是： 总页码减 4 - 总页码

		![image-20211113224154349](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113224154349.png)

	- 小情况 3： 4， 5， 6， 7， 页码范围是： 当前页码减 2 - 当前页码加 2

		![image-20211113224239686](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113224239686.png)

```java
    <%--页码输出的开始--%>
    <c:choose>
        <%--情况 1： 如果总页码小于等于 5 的情况， 页码的范围是： 1-总页码--%>
        <c:when test="${ requestScope.page.pageTotal <= 5 }">
            <c:set var="begin" value="1"/>
            <c:set var="end" value="${requestScope.page.pageTotal}"/>
        </c:when>
        <%--情况 2： 总页码大于 5 的情况--%>
        <c:when test="${requestScope.page.pageTotal > 5}">
            <c:choose><%--小情况 1： 当前页码为前面 3 个： 1， 2， 3 的情况， 页码范围是： 1-5.--%>
                <c:when test="${requestScope.page.pageNo <= 3}">
                    <c:set var="begin" value="1"/>
                    <c:set var="end" value="5"/>
                </c:when>
                <%--小情况 2： 当前页码为最后 3 个， 8， 9， 10， 页码范围是： 总页码减 4 - 总页码--%>
                <c:when test="${requestScope.page.pageNo > requestScope.page.pageTotal-3}">
                    <c:set var="begin" value="${requestScope.page.pageTotal-4}"/>
                    <c:set var="end" value="${requestScope.page.pageTotal}"/>
                </c:when>
                <%--小情况 3： 4， 5， 6， 7， 页码范围是： 当前页码减 2 - 当前页码加 2--%>
                <c:otherwise>
                    <c:set var="begin" value="${requestScope.page.pageNo-2}"/>
                    <c:set var="end" value="${requestScope.page.pageNo+2}"/>
                </c:otherwise>
            </c:choose>
        </c:when>
    </c:choose>
    <c:forEach begin="${begin}" end="${end}" var="i">
        <c:if test="${i == requestScope.page.pageNo}">
            【${i}】
        </c:if>
        <c:if test="${i != requestScope.page.pageNo}">
            <a href="${requestScope.page.url}&pageNo=${i}">${i}</a>
        </c:if>
    </c:forEach>
    <%--页码输出的结束--%>

```





### 七、修改分页后， 增加， 删除， 修改图书信息的回显页面

以修改图书为示例：  

- 1、 在修改的请求地址上追加当前页码参数：  

	![image-20211113224338692](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113224338692.png)

- 2、 在 book_edit.jsp 页面中使用隐藏域记录下 pageNo 参数

	![image-20211113224401079](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113224401079.png)

- 3、 在服务器重定向的时候， 获取当前页码追加上进行跳转

	```java
	protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException,
	IOException {
	    // 1、 获取请求的参数==封装成为 Book 对象
	    Book book = WebUtils.copyParamToBean(req.getParameterMap(),new Book());
	    // 2、 调用 BookService.updateBook( book );修改图书
	    bookService.updateBook(book);// 3、 重定向回图书列表管理页面
	    // 地址： /工程名/manager/bookServlet?action=list
	    resp.sendRedirect(req.getContextPath() + "/manager/bookServlet?action=page&pageNo=" +
	    req.getParameter("pageNo"));
	}
	```

	

### 八、首页 index.jsp 的跳转

![image-20211113224543439](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113224543439.png)



### 九、分页条的抽取

#### 1、抽取分页条中请求地址为 url 变量

##### 1.1、在 page 对象中添加 url 属性

```java
/**
* Page 是分页的模型对象
* @param <T> 是具体的模块的 javaBean 类
*/
public class Page<T> {
    public static final Integer PAGE_SIZE = 4;
    // 当前页码
    private Integer pageNo;
    // 总页码
    private Integer pageTotal;
    // 当前页显示数量
    private Integer pageSize = PAGE_SIZE;
    // 总记录数
    private Integer pageTotalCount;
    // 当前页数据
    private List<T> items;
    // 分页条的请求地址
    private String url;
```

##### 1.2、在 Servlet 程序的 page 分页方法中设置 url 的分页请求

![image-20211113224751365](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113224751365.png)

##### 1.3、 修改分页条中请求地址为 url 变量输出,并抽取一个单独的 jsp 页面

![image-20211115094714402](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211115094714402.png)

```jsp
<%--
  Created by IntelliJ IDEA.
  User: kingb
  Date: 2021/11/15
  Time: 8:03
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%--      分页条的开始--%>
<div id="page_nav">
    <%--当前页面大于1，才显示首页和上一页操作，要不然第一页你再上一页跑哪去了？？？？          --%>
    <c:if test="${requestScope.page.pageNo >1}">
        <a href="${requestScope.page.url}&pageNo=1">首页</a>
        <a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo - 1}">上一页</a>
    </c:if>

    <%--页码输出的开始--%>
    <c:choose>
        <%--情况 1： 如果总页码小于等于 5 的情况， 页码的范围是： 1-总页码--%>
        <c:when test="${ requestScope.page.pageTotal <= 5 }">
            <c:set var="begin" value="1"/>
            <c:set var="end" value="${requestScope.page.pageTotal}"/>
        </c:when>
        <%--情况 2： 总页码大于 5 的情况--%>
        <c:when test="${requestScope.page.pageTotal > 5}">
            <c:choose><%--小情况 1： 当前页码为前面 3 个： 1， 2， 3 的情况， 页码范围是： 1-5.--%>
                <c:when test="${requestScope.page.pageNo <= 3}">
                    <c:set var="begin" value="1"/>
                    <c:set var="end" value="5"/>
                </c:when>
                <%--小情况 2： 当前页码为最后 3 个， 8， 9， 10， 页码范围是： 总页码减 4 - 总页码--%>
                <c:when test="${requestScope.page.pageNo > requestScope.page.pageTotal-3}">
                    <c:set var="begin" value="${requestScope.page.pageTotal-4}"/>
                    <c:set var="end" value="${requestScope.page.pageTotal}"/>
                </c:when>
                <%--小情况 3： 4， 5， 6， 7， 页码范围是： 当前页码减 2 - 当前页码加 2--%>
                <c:otherwise>
                    <c:set var="begin" value="${requestScope.page.pageNo-2}"/>
                    <c:set var="end" value="${requestScope.page.pageNo+2}"/>
                </c:otherwise>
            </c:choose>
        </c:when>
    </c:choose>
    <c:forEach begin="${begin}" end="${end}" var="i">
        <c:if test="${i == requestScope.page.pageNo}">
            【${i}】
        </c:if>
        <c:if test="${i != requestScope.page.pageNo}">
            <a href="${requestScope.page.url}&pageNo=${i}">${i}</a>
        </c:if>
    </c:forEach>
    <%--页码输出的结束--%>


    <%--当前页面小于总页数，才显示末页和下一页操作，要不然最后一页你再下一页跑哪去了？？？？       --%>
    <c:if test="${requestScope.page.pageNo < requestScope.page.pageTotal}" >
        <a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo + 1}">下一页</a>
        <a href="${requestScope.page.url}&pageNo=${requestScope.page.pageTotal}">末页</a>
    </c:if>
    共${requestScope.page.pageTotal}页，${requestScope.page.pageTotalCount}条记录
    到第<input value="${param.pageNo == null ? 1 : param.pageNo }" name="pn" id="pn_input"/>页
    <input id="searchPageBtn" type="button" value="确定">

</div>
<%--      分页条的结束--%>
```





### 十、首页价格搜索

![image-20211113224917547](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113224917547.png)



clientBookServlet程序：

```java
protected void pageByPrice(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    // 1、获取请求参数 pageNo、pageSize、min、max【直接转换成整型】
    int pageNo = WebUtils.parseInt(request.getParameter("pageNo"), 1);
    int pageSize = WebUtils.parseInt(request.getParameter("pageSize"), Page.PAGE_SIZE);
    int min = WebUtils.parseInt(request.getParameter("min"), 0);
    int max = WebUtils.parseInt(request.getParameter("max"), Integer.MAX_VALUE);
    // 2、调用BookService.pageByPrice(pageNo,pageSize,min,max)方法，返回Page对象
    Page<Book> page = bookService.pageByPrice(pageNo,pageSize,min,max);


    StringBuilder stringBuilder = new StringBuilder("client/bookServlet?action=pageByPrice");
    // 如果有最小价格参数，追加到分页条的地址栏参数中
    if (request.getParameter("min") != null)
        stringBuilder.append("&min=").append(request.getParameter("min"));
    // 如果有最大价格参数，追加到分页条的地址栏参数中
    if (request.getParameter("max") != null)
        stringBuilder.append("&max=").append(request.getParameter("max"));


    page.setUrl(stringBuilder.toString());

    // 3、保存Page对象到Request 域中
    request.setAttribute("page",page);
    // 4、请求转发到pages/manager/book_manager.jsp
    // !!!!!!请求转发别忘了.forward(request,response)
    request.getRequestDispatcher("/pages/client/index.jsp").forward(request,response);
}
```



BookService程序

```java
@Override
public Page<Book> pageByPrice(int pageNo, int pageSize,int min,int max) {
    Page<Book> page = new Page<>();
    // 每页展示数量
    page.setPageSize(pageSize);
    // 总记录数
    Integer pagePriceTotalCount = bookDao.queryForPriceTotalCount(min,max);
    page.setPageTotalCount(pagePriceTotalCount);
    // 总页数【如果不是整除，证明页面放不下，在后面追加一个页面】
    page.setPageTotal(pagePriceTotalCount % pageSize > 0 ? pagePriceTotalCount/pageSize + 1 : pagePriceTotalCount/pageSize);

    // 当前页码
    page.setPageNo(pageNo);//【因为，setPageNo方法，要用到pageTotal总页数属性，所以先设置总页数，在设置当前页】

    // 当前页面展示内容
    int begin = (page.getPageNo() - 1) * pageSize; // 因为setPageNo()方法有可能重置pageNo的值，所以用get方法，不用直接传的参数
    // 【索引开始值，假设每页4个，第3页开始第一个索引就是2*4】
    List<Book> booksItems = bookDao.queryForPricePageItems(begin,pageSize,min,max);
    page.setItems(booksItems);
    return page;
}
```

BookDao程序

```java
@Override
    public Integer queryForPriceTotalCount(int min,int max) {
        String sql = "select count(*) from t_book where `price` > ? and `price` < ?";
//        String sql = "select count(*) from t_book where `price` between ? and ?";
        Number count = (Number)queryForSingleValue(sql, min, max);
        return count.intValue();
    }

    @Override
    public List<Book> queryForPricePageItems(int begin, int pageSize, int min, int max) {
        String sql = "select * from t_book where `price` between ? and ? order by `price` limit ?,?";
        return queryForList(Book.class,sql,min,max,begin,pageSize);
    }
```

#### 解决页面分页条，不根据筛选结果翻页问题

在bookServlet程序中添加如下代码

【就是判断min和max是不是存在，<font color='red'>若存在就把他加到请求转发的地址栏中</font>】

```java
StringBuilder stringBuilder = new StringBuilder("client/bookServlet?action=pageByPrice");
// 如果有最小价格参数，追加到分页条的地址栏参数中
if (request.getParameter("min") != null)
    stringBuilder.append("&min=").append(request.getParameter("min"));
// 如果有最大价格参数，追加到分页条的地址栏参数中
if (request.getParameter("max") != null)
    stringBuilder.append("&max=").append(request.getParameter("max"));
page.setUrl(stringBuilder.toString());
```



## 17、登陆模块

### 一、登录----显示用户名

UserServlet 程序中保存用户登录的信息  

![image-20211115102419885](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211115102419885.png)

修改 login_succuess_menu.jsp

![image-20211115102433575](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211115102433575.png)

还要修改首页 index.jsp 页面的菜单 ：  

![image-20211115102448780](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211115102448780.png)



### 二、登出---注销用户

​		1、 销毁 Session 中用户登录的信息（或者销毁 Session）
​		2、 重定向到首页（或登录页面） 。



UserServlet 程序中添加 logout 方法  

```java
/**
* 注销
* @param req
* @param resp
* @throws ServletException
* @throws IOException
*/
protected void logout(HttpServletRequest req, HttpServletResponse resp) throws ServletException,IOException {
    // 1、 销毁 Session 中用户登录的信息（或者销毁 Session）
    req.getSession().invalidate();
    // 2、 重定向到首页（或登录页面） 。
    resp.sendRedirect(req.getContextPath());
}
```

修改【注销】 的菜单地址

```jsp
<a href="userServlet?action=logout">注销</a>
```

### 三、表单重复提交之-----使用验证码解决  

表单重复提交有三种常见的情况：

- 一： 提交完表单。 服务器使用请求转来进行页面跳转。 这个时候， 用户按下功能键 F5， 就会发起最后一次的请求。造成表单重复提交问题。 
	- 解决方法： <font color=red>使用重定向来进行跳转</font>
- 二： 用户正常提交服务器， 但是由于网络延迟等原因， 迟迟未收到服务器的响应， 这个时候， 用户以为提交失败，就会着急， 然后多点了几次提交操作， 也会造成表单重复提交。
- 三： 用户正常提交服务器。 服务器也没有延迟， 但是提交完成后， 用户回退浏览器。 重新提交。 也会造成表单重复提交。  

<font color=red>第二、三种重复提交，他一提交，验证码就在session中获取后被删除了，下次再获取的就跟之前的不一样了，验证码不一样重复提交操作就被阻止了</font>

![image-20211115102713250](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211115102713250.png)



### 四、谷歌 kaptcha 图片验证码的使用

谷歌验证码 kaptcha 使用步骤如下：
		1、 导入谷歌验证码的 jar 包
				kaptcha-2.3.2.jar
		2、 在 web.xml 中去配置用于生成验证码的 Servlet 程序  【这Servlet程序jar包已经写了，直接配置就行了】

```java
<servlet>
    <servlet-name>KaptchaServlet</servlet-name>
    <servlet-class>com.google.code.kaptcha.servlet.KaptchaServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>KaptchaServlet</servlet-name>
    <url-pattern>/kaptcha.jpg</url-pattern>
</servlet-mapping>
```

​		3、 在表单中使用 img 标签去显示验证码图片并使用它  

```jsp
<form action="http://localhost:8080/tmp/registServlet" method="get">
    用户名： <input type="text" name="username" > <br>
    验证码： <input type="text" style="width: 80px;" name="code">
    <img src="http://localhost:8080/tmp/kaptcha.jpg" alt="" style="width: 100px; height: 28px;"> <br>
    <input type="submit" value="登录">
</form>
```

​		4、 在服务器获取谷歌生成的验证码和客户端发送过来的验证码比较使用。  

```java
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,IOException {
    // 获取 Session 中的验证码
    String token = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY);
    // 删除 Session 中的验证码
    req.getSession().removeAttribute(KAPTCHA_SESSION_KEY);
    String code = req.getParameter("code");
    // 获取用户名
    String username = req.getParameter("username");
    if (token != null && token.equalsIgnoreCase(code)) {
        System.out.println("保存到数据库： " + username);
        resp.sendRedirect(req.getContextPath() + "/ok.jsp");
    } else {
   		System.out.println("请不要重复提交表单");
    }
}
```

切换验证码：  

- 在事件响应的 function 函数中有一个 this 对象。
- 这个 this 对象， 是当前正在响应事件的 dom 对象【这里就是验证码的那个img标签】
- src 属性表示验证码 img 标签的 图片路径。 它可读， 可写

- **this.src = "${basePath}/kaptcha.jpg"【本来这样就可以实现了】**
- 但是除了谷歌浏览器外，其他浏览器将数据缓存在浏览器，每次点击实际访问地址一样，
- 就不会实现更新，在后边加一个参数并赋随机的值，让每次参数都不一样
- 最好的方法就是加一个时间，因为时间永远不会相同



```javascript
// 给验证码的图片， 绑定单击事件
$("#code_img").click(function () {
    // 在事件响应的 function 函数中有一个 this 对象。 这个 this 对象， 是当前正在响应事件的 dom 对象
    // src 属性表示验证码 img 标签的 图片路径。 它可读， 可写
    // alert(this.src);
    this.src = "${basePath}kaptcha.jpg?d=" + new Date();
});
```



## 18、购物车模块

### 一 、购物车模块分析

![image-20211113225705436](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113225705436.png)



### 二、购物车模型编写【这个模块用session处理，未使用数据库】

#### 2.1、购物车模型

**cart类**牌【购物车框架】【这个类要注意，不是单纯地属性方法，未设置属性，直接设置get方法】

```java
package com.tianhao.bean;

import java.math.BigDecimal;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * @ClassName Cart
 * @Description TODO:购物车对象
 * @Author sth_199509@163.com
 * @Date 2021/11/16 8:45
 * @Version 1.0
 */
public class Cart {
    //Fields
    // 这两个属性因为是根据购物车中的情况确定的，不能给他赋值，
    // 所以直接用一个get方法就行了，在里面定义变量，set方法也就不能用了
//    private Integer totalCount;
//    private BigDecimal totalPrice;
    private Map<Integer,CartItem> items = new LinkedHashMap<>();
    //Constructors
    public Cart() {}

    //Methods

    /**
     * 添加商品信息
     * @param cartItem
     */
    public void addItem(CartItem cartItem) {
        // 先查看 购物车中是否已经存在该商品，存在：价格增加，不存在：商品加入
        CartItem item = items.get(cartItem.getId());
        if (item == null){
            // 之前没添加过此商品
            items.put(cartItem.getId(), cartItem);
        }else{
            // 已经存在
            item.setCount(item.getCount() + 1); // 数量加一
            item.setTotalPrice(item.getTotalPrice().add(item.getPrice()));// 总价格加单价

        }
    }

    public void deleteItem(Integer id) {
        items.remove(id);
    }

    public void clear() {
        items.clear();
    }

    public void updateCount(Integer id, Integer count) {
        // 先查看 购物车中是否已经存在该商品，存在：修改
        CartItem item = items.get(id);
        if (item != null){
            item.setCount(count); // 数量修改
            item.setTotalPrice(item.getPrice().multiply(new BigDecimal(count)));// 总价格加单价
        }
    }
    public Integer getTotalCount() {
        Integer totalCount = 0;
        for(Map.Entry<Integer,CartItem> entry : items.entrySet()){
            totalCount += entry.getValue().getCount();
        }
        return totalCount;
    }


    public BigDecimal getTotalPrice() {
        BigDecimal totalPrice = new BigDecimal(0);
        for(Map.Entry<Integer,CartItem> entry : items.entrySet()){
            totalPrice = totalPrice.add(entry.getValue().getTotalPrice());
        }
        return totalPrice;
    }


    public Map<Integer, CartItem> getItems() {
        return items;
    }

    public void setItems(Map<Integer, CartItem> items) {
        this.items = items;
    }

    @Override
    public String toString() {
        return "Cart{" +
                "totalCount=" + getTotalCount() +
                ", totalPrice=" + getTotalPrice() +
                ", items=" + items +
                '}';
    }
}
```

**cartItem类**【具体的商品条目】

```java
package com.tianhao.bean;

import java.math.BigDecimal;

/**
 * @ClassName CartTtem
 * @Description TODO:购物车的商品项
 * @Author sth_199509@163.com
 * @Date 2021/11/16 8:41
 * @Version 1.0
 */
public class CartItem {
    //Fields
    private Integer id;
    private String name;
    private Integer count;
    private BigDecimal price;
    private BigDecimal totalPrice;
    //Constructors
    public CartItem() {}
    public CartItem(Integer id, String name, Integer count, BigDecimal price, BigDecimal totalPrice) {
        this.id = id;
        this.name = name;
        this.count = count;
        this.price = price;
        this.totalPrice = totalPrice;
    }
    //Methods
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getCount() {
        return count;
    }

    public void setCount(Integer count) {
        this.count = count;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal prive) {
        this.price = prive;
    }

    public BigDecimal getTotalPrice() {
        return totalPrice;
    }

    public void setTotalPrice(BigDecimal totalPrice) {
        this.totalPrice = totalPrice;
    }
    @Override
    public String toString() {
        return "CartItem{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", count=" + count +
                ", prive=" + price +
                ", totalPrice=" + totalPrice +
                '}';
    }
}
```







### 三、加入购物车功能的实现

CartServlet 程序中的代码：

```java

public class CartServlet extends BaseServlet {
    private BookService bookService = new BookServiceImpl();

    protected void addItem(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取请求的参数，商品编号
        int id = WebUtils.parseInt(request.getParameter("id"),0);
        // 调用bookService.queryBookById(id);得到图书的信息
        Book book = bookService.queryBookById(id);
        // 把图书的信息，转换成为CartItem商品项
        CartItem cartItem = new CartItem(id, book.getName(), 1, book.getPrice(), book.getPrice());
        // 调用Cart.addItem(CartItem);添加商品
        Cart cart = (Cart)request.getSession().getAttribute("cart");
        // 防止每次添加，都换新的车，这里把车保存在Session会话中
        if (cart == null){
            cart = new Cart();
            request.getSession().setAttribute("cart",cart);
        }
        cart.addItem(cartItem);
        // 在session域中，保存最后一个加入的商品名称
        request.getSession().setAttribute("last",cartItem.getName());
        // 重定向回商品列表页面【回到原来商品所在的页面---加入购物车时的地址栏地址包含参数如页面】
        response.sendRedirect(request.getHeader("Referer"));
    }
   
}
```



index.jsp 页面 js 的代码：

![image-20211113230046999](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113230046999.png)







图解说明， 如何跳回添加商品的页面：  

![image-20211113230116095](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113230116095.png)





### 四、购物车的展示

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>购物车</title>
   <%--静态包含 base标签、css样式、jQuery文件--%>
   <%@ include file="/pages/common/head.jsp"%>
   <script type="text/javascript">
      $(function () {
         // 给删除绑定单击事件，删除前确认一下
         $("a.deleteItem").click(function () {
            return confirm("你确定要删除《" + $(this).parent().parent().find("td:first").text() + "》吗？？？");
         });
         // 给清空购物车绑定单击事件，清空之前确认一下
         $("a.clear").click(function () {
            return confirm("你确定要清空购物车的所有商品吗？？？");
         });
         // 给修改购物车商品数量绑定【onchange事件】【内容发生变化，触发，省去了判断是否更改了】
         $("input.updateCount").change(function () {
            // 1、获取商品名称及id
            var name = $(this).parent().parent().find("td:first").text();
            var id = $(this).attr("bookId");
            // 2、获取商品修改后的数量
            var count = this.value;
            // 3、根据用户选择是否确认修改，产生不同结果
            if( confirm("你确定要将《" + name + "》的数量修改为：" + count + "吗?")){
               // 同意修改，跳转到CartServlet进行修改操作
               location.href = "http://localhost:8080/Books/cartServlet?action=updateCount&count=" + count +"&id=" + id;
            }else{
               // 放弃修改，恢复默认值
               this.value = this.defaultValue;
            }
         });
      });
   </script>

</head>
<body>
   
   <div id="header">
         <img class="logo_img" alt="" src="static/img/logo.gif" >
         <span class="wel_word">购物车</span>
      <%--静态包含，登陆成功的页面    直接写地址，是因为上边有base标签--%>
      <%@ include file="/pages/common/login_success_page.jsp"%>
   </div>
   
   <div id="main">
   
      <table>
         <tr>
            <td>商品名称</td>
            <td>数量</td>
            <td>单价</td>
            <td>金额</td>
            <td>操作</td>
         </tr>
         <c:if test="${empty sessionScope.cart.items}">
            <%--购物车为空--%>
            <tr>
               <td colspan="5"><a href="index.jsp">亲！当前购物车是空的，快去逛逛吧！</a></td>
               <td></td>
               <td></td>
               <td></td>
               <td></td>
            </tr>
         </c:if>

         <c:if test="${not empty sessionScope.cart.items}">
            <%--购物车不空--%>
            <c:forEach items="${sessionScope.cart.items}" var="entry">
               <tr>
                  <td>${entry.value.name}</td>
                  <td>
                     <input class="updateCount" style="width: 50px;" type="text" bookId="${entry.value.id}" value="${entry.value.count}">
                  </td>
                  <td>${entry.value.price}</td>
                  <td>${entry.value.totalPrice}</td>
                  <td><a class="deleteItem" href="cartServlet?action=deleteItem&id=${entry.value.id}">删除</a></td>
               </tr>
            </c:forEach>
         </c:if>

      </table>
<%--      购物车空的时候就不显示下面的金额之类的--%>
      <c:if test="${not empty sessionScope.cart.items}">
         <div class="cart_info">
            <span class="cart_span">购物车中共有<span class="b_count">${sessionScope.cart.totalCount}</span>件商品</span>
            <span class="cart_span">总金额<span class="b_price">${sessionScope.cart.totalPrice}</span>元</span>
            <span class="cart_span"><a class="clear" href="cartServlet?action=clear">清空购物车</a></span>
            <span class="cart_span"><a href="orderServlet?action=createOrder">去结账</a></span>
         </div>
      </c:if>
   </div>


   <%--静态包含，页脚信息  --%>
   <%@include file="/pages/common/footer.jsp"%>


</body>
</html>
```



### 五、删除购物车商品项

CartServlet 程序：

```java
public class CartServlet extends BaseServlet {
    private BookService bookService = new BookServiceImpl();

    protected void deleteItem(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 1、获取请求的参数
        int id = WebUtils.parseInt(request.getParameter("id"), 1);
        // 2、获取购物车对象
        Cart cart = (Cart) request.getSession().getAttribute("cart");
        if (cart != null){
            // 删除购物车商品
            cart.deleteItem(id);
            // 重定向 回到删除之前的页面
            response.sendRedirect(request.getHeader("Referer"));
        }
    }
}
```





购物车/pages/cart/cart.jsp 页面的代码：

删除的请求地址

![image-20211113230227318](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113230227318.png)

删除的确认提示操作：

```jsp
<script type="text/javascript">
    $(function () {
        // 给 【删除】 绑定单击事件
        $("a.deleteItem").click(function () {
        	return confirm("你确定要删除【" + $(this).parent().parent().find("td:first").text() +"】 吗?")
    	});
    });
</script>
```



### 六、清空购物车

CartServlet 程序

```java

public class CartServlet extends BaseServlet {
    private BookService bookService = new BookServiceImpl();

    protected void clear(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Cart cart = (Cart) request.getSession().getAttribute("cart");
        if (cart != null)
            cart.clear();
        response.sendRedirect(request.getHeader("Referer"));
    }
}
```





cart.jsp 页面的内容
给清空购物车添加请求地址， 和添加 id 属性：  

![image-20211113230358531](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113230358531.png)

清空的确认提示操作：

```javascript
// 给清空购物车绑定单击事件
$("#clearCart").click(function () {
	return confirm("你确定要清空购物车吗?");
});
```



### 七、修改购物车商品数量

CartServlet 程序

```java


public class CartServlet extends BaseServlet {
    private BookService bookService = new BookServiceImpl();

    protected void updateCount(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取请求的参数，商品编号及要修改的数量
        int id = WebUtils.parseInt(request.getParameter("id"),0);
        int count = WebUtils.parseInt(request.getParameter("count"),1);

        Cart cart = (Cart)request.getSession().getAttribute("cart");
        // 防止每次添加，都换新的车，这里把车保存在Session会话中
        if (cart != null){
            cart.updateCount(id,count);
            // 重定向回商品列表页面【回到原来商品所在的页面---加入购物车时的地址栏地址包含参数如页面】
            response.sendRedirect(request.getHeader("Referer"));
        }
    }
}
```



修改 pages/cart/cart.jsp 购物车页面：

![image-20211113230556827](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113230556827.png)

修改商品数量 js 代码：  

```javascript
// 给修改购物车商品数量绑定【onchange事件】【内容发生变化，触发，省去了判断是否更改了】

$("input.updateCount").change(function () {
   // 1、获取商品名称及id
   var name = $(this).parent().parent().find("td:first").text();
   var id = $(this).attr("bookId");
   // 2、获取商品修改后的数量
   var count = this.value;
   // 3、根据用户选择是否确认修改，产生不同结果
   if( confirm("你确定要将《" + name + "》的数量修改为：" + count + "吗?")){
      // 同意修改，跳转到CartServlet进行修改操作
      location.href = "http://localhost:8080/Books/cartServlet?action=updateCount&count=" + count +"&id=" + id;
   }else{
      // 放弃修改，恢复默认值
      this.value = this.defaultValue;
   }
});
```









### 八、首页， 购物车数据回显

在添加商品到购物车的时候， 保存最后一个添加的商品名称：

![image-20211113230640569](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113230640569.png)

在 pages/client/index.jsp 页面中输出购物车信息：

```jsp
<div style="text-align: center">
   <%--购物车为空--%>
   <c:if test="${empty sessionScope.cart.items}">
      <span></span>
      <div>
         <span style="color: red">当前购物车为空</span>
      </div>
   </c:if>
   <%--购物车不空--%>
   <c:if test="${not empty sessionScope.cart.items}">
      <span>您的购物车中有${sessionScope.cart.totalCount}件商品</span>
      <div>
         您刚刚将<span style="color: red">${sessionScope.last}</span>加入到了购物车中
      </div>
   </c:if>
</div>
```



## 19、订单模块

### 一、订单模块的分析：

![image-20211113230736403](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113230736403.png)

### 二、订单模块的实现

#### 2.1、创建订单模块的数据库表

```sql
-- 判断t_order表是否存在，存在就删除
drop table if exists t_order;

-- 判断t_order_item表是否存在，存在就删除
drop table if exists t_order_item;

create table t_order(
		`order_id` varchar(50) primary key,
		`create_time` datetime,
		`price` decimal(11,2),
		`status` int,  -- 发货状态【0未发货、1已发货、2已签收】
		`user_id` int,
		foreign key(`user_id`) references t_user(`id`) 
    -- 外键，只能绑定在已有用户的id下面【甲用户在数据库中，则可以为甲创建订单，假设A订单】
);

create table t_order_item(
		`id` int primary key auto_increment,
		`name` varchar(100),
		`count` int,
		`price` decimal(11,2),
		`total_price` decimal(11,2),
		`order_id` varchar(50),
		foreign key(`order_id`) references t_order(`order_id`) 
    -- 外键，只能绑定在某个已存在订单编号下面【A订单已存在，可以为A订单添加不同的上商品信息】
);

```



#### 2.2、创建订单模块的数据模型

Order类【订单框架类】

```java
package com.tianhao.bean;

import java.math.BigDecimal;
import java.util.Date;

/**
 * @ClassName Order
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/16 16:02
 * @Version 1.0
 */
public class Order {
    // Fields
    private String order_id;
    private Date create_time;
    private BigDecimal price;
    private Integer status = 0;//发货状态【0未发货、1已发货、2已签收】
    private Integer user_id;

    // Constructors
    public Order() {}
    public Order(String order_id, Date createTime, BigDecimal price, Integer status, Integer user_id) {
        this.order_id = order_id;
        this.create_time = createTime;
        this.price = price;
        this.status = status;
        this.user_id = user_id;
    }

    // Methods
    public String getOrder_id() {
        return order_id;
    }

    public void setOrder_id(String order_id) {
        this.order_id = order_id;
    }

    public Date getCreate_time() {
        return create_time;
    }

    public void setCreate_time(Date createTime) {
        this.create_time = createTime;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    public Integer getStatus() {
        return status;
    }

    public void setStatus(Integer status) {
        this.status = status;
    }

    public Integer getUser_id() {
        return user_id;
    }

    public void setUser_id(Integer user_id) {
        this.user_id = user_id;
    }

    @Override
    public String toString() {
        return "Order{" +
                "order_id='" + order_id + '\'' +
                ", createTime=" + create_time +
                ", price=" + price +
                ", status=" + status +
                ", user_id=" + user_id +
                '}';
    }
}
```

OrderItem类【具体的每条订单信息】

```java
package com.tianhao.bean;

import java.math.BigDecimal;

/**
 * @ClassName OrderItem
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/16 16:07
 * @Version 1.0
 */
public class OrderItem {
    // Fields
    private Integer id;
    private String name;
    private Integer count;
    private BigDecimal price;
    private BigDecimal total_Price;
    private String order_id;

    // Constructors
    public OrderItem(){}
    public OrderItem(Integer id, String name, Integer count, BigDecimal price, BigDecimal total_Price, String order_id) {
        this.id = id;
        this.name = name;
        this.count = count;
        this.price = price;
        this.total_Price = total_Price;
        this.order_id = order_id;
    }

    // Methods
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getCount() {
        return count;
    }

    public void setCount(Integer count) {
        this.count = count;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    public BigDecimal getTotal_Price() {
        return total_Price;
    }

    public void setTotal_Price(BigDecimal total_Price) {
        this.total_Price = total_Price;
    }

    public String getOrder_id() {
        return order_id;
    }

    public void setOrder_id(String order_id) {
        this.order_id = order_id;
    }

    @Override
    public String toString() {
        return "OrderItem{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", count=" + count +
                ", price=" + price +
                ", total_Price=" + total_Price +
                ", order_id='" + order_id + '\'' +
                '}';
    }
}
```



#### 2.3、 编写订单模块的 Dao 程序和测试

OrderDao 接口：



OrderDao 实现：



OrderItemDao 接口：



OrderItemDao 实现：







测试：



#### 2.4、 编写订单模块的 Service 和测试

OrderService 接口 ：



OrderService 实现类：



测试：





#### 2.5、 编写订单模块的 web 层和页面联调

修改 OrderService 程序：



OrderServlet 程序：



修改 pages/cart/cart.jsp 页面， 结账的请求地址：

![image-20211113231308640](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113231308640.png)

修改 pages/cart/checkout.jsp 页面， 输出订单号：

![image-20211113231324345](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211113231324345.png)



## 20、Filter实现过滤

#### 1、使用 Filter 过滤器拦截/pages/manager/所有内容， 实现权限检查  

Filter 代码：  

```java
package com.tianhao.filter; /**
 * @ClassName ${NAME}
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/17 20:13
 * @Version 1.0
 */

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class ManagerFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {
        
        HttpServletRequest request1 = (HttpServletRequest) request;
        Object user = request1.getSession().getAttribute("user");
        if (user == null){
            request1.getRequestDispatcher("/pages/user/login.jsp").forward(request,response);
        }else{
            // 放行
            chain.doFilter(request, response);
        }
    }
}
```

web.xml 中的配置：

- 这里面直接拦截一个地址不行，有的通过servlet程序跳进去的，

- 在地址拦截处可以增加拦截

```xml
    <filter>
        <filter-name>ManagerFilter</filter-name>
        <filter-class>com.tianhao.filter.ManagerFilter</filter-class>
    </filter>
    
    <filter-mapping>
        <filter-name>ManagerFilter</filter-name>
        <url-pattern>/pages/manager/*</url-pattern>
        <url-pattern>/manager/bookServlet;</url-pattern>
    </filter-mapping>

</web-app>
```



#### 2、 ThreadLocal 的使用

ThreadLocal 的作用， 它可以解决多线程的数据安全问题。
ThreadLocal 它可以给当前线程关联一个数据（可以是普通变量， 可以是对象， 也可以是数组， 集合）

<font color='red'>【就是多线程的时候，给每个线程可以赋个值，跟map一样，可以区分线程】</font>

- ThreadLocal 的特点：

	- 1、 ThreadLocal 可以为当前线程关联一个数据。 （它可以像 Map 一样存取数据， key 为当前线程）
	- 2、 每一个 ThreadLocal 对象， 只能为当前线程关联一个数据， 如果要为当前线程关联多个数据， 就需要使用多个ThreadLocal 对象实例。
		- <font color='red'>每个线程只能赋一个值，第二次赋值会覆盖之前的</font>
	- 3、 每个 ThreadLocal 对象实例定义的时候， 一般都是 static 类型
	- 4、 ThreadLocal 中保存数据， 在线程销毁后。 会由 JVM 虚拟自动释放。  

- 使用方法：

	```java
	// 1、创建ThreadLocal对象
	public static ThreadLocal<Object> threadLocal = new ThreadLocal<>();
	
	// 2、线程运行后，给他赋值i，i可以是任何类型
	threadLocal.set(i);
	
	// 3、获取当前线程的赋值
	Object o = threadLocal.get();
	```

	



测试类：

```java
package com.tianhao.threadlocal;

import java.util.Random;

/**
 * @ClassName ThreadLocalTest
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/17 20:44
 * @Version 1.0
 */
public class ThreadLocalTest {
//    public static Hashtable<String, Object> map = new Hashtable<>();
    public static ThreadLocal<Object> threadLocal = new ThreadLocal<>();
    private static Random random = new Random();


    public static void main(String[] args){
        for (int i = 0; i < 3; i++) {
            new Thread(new Task()).start();
        }
    }

    public static class Task implements Runnable{

        @Override
        public void run(){
            // 在run方法中，随机生成一个变量（线程要关联的数据），然后以当前线程名为key，保存到map中
            int i = random.nextInt(1000); // 1000以内的随机整数
            // 获取当前线程名
            String name = Thread.currentThread().getName();
            System.out.println("线程【" + name + "】生成的随机数是：" + i);
//            map.put(name,i);
            threadLocal.set(i);

            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }


            // 在Run方法结束之前，以当前线程名获取出数据并打印，查看是否可以取出操作
//            Object o = map.get(name);
            Object o = threadLocal.get();
            System.out.println("在线程【" + name + "】快结束时取出关联的数据是：" + o);
        }
    }
}
```



#### 3、使用 Filter 和 ThreadLocal 组合管理事务

##### 3.1、 使用 ThreadLocal 来确保所有 dao 操作都在同一个 Connection 连接对象中完成

<font color='red'>【就是：因为涉及数据库，就要考虑数据库事务】</font>

- **<font color='blue'>但是因为用的数据库连接池，获取的连接具有不确定性</font>**
- **<font color='blue'>第一次获取连接时，存到ThreadLocal中</font>**
- **<font color='blue'>然后，关闭自动提交、手动提交、回滚事务、关闭连接等操作，要用到connection</font>**
- **<font color='blue'>这个连接全部用ThreadLocal 获取刚才保存到，这样就是多线程也不怕了</font>**

原理分析图：  

![image-20211117201029979](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211117232532444.png)

###### JdbcUtils 工具类的修改：  

主要修改：

- 使用ThreadLocal对象，确保处理的连接是同一个，一个线程一个连接
- 增加了事务回滚和事务手动提交

```java
package com.tianhao.utils;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Properties;

/**
 * @ClassName JdbcUtils
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/8 21:29
 * @Version 1.0
 */
public class JdbcUtils {
    /**
     * 获取数据库连接池中的连接
     * @return null表示获取连接失败，有值就是成功
     */

    private static ThreadLocal<Connection> conns = new ThreadLocal<>();
    private static DataSource sourceDruid;
    //同理，将数据库连接池的创建放到外边，要不然创建n个池子干啥
    //因为涉及到流加载，不能直接声明，通过声明静态代码块，随着类的加载而加载
    static{
        try {
            Properties pros = new Properties();
            // 读取jdbc.properties 属性配置文件
//            InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("jdbc.properties");
            InputStream is = JdbcUtils.class.getClassLoader().getResourceAsStream("jdbc.properties");
            // 从流中加载数据
            pros.load(is);
            // 创建数据库连接池
            sourceDruid = DruidDataSourceFactory.createDataSource(pros);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static Connection getConnection(){
        Connection connection = conns.get();
        if (connection == null){
            try {
                connection = sourceDruid.getConnection();// 从数据库连接池中获取连接
                conns.set(connection); // 保存到ThreadLocal对象中，供后边的jdbc操作使用
                connection.setAutoCommit(false); // 设置为手动管理事务
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return connection;
    }

    /**
     * 提交事务，并关闭连接
     */
    public static void commitAndClose(){
        // 直接从ThreadLocal对象中获取连接，可能不存在
        Connection connection = conns.get();
        if (connection != null){ // 如果不等于null，说明之前使用过连接，操作过数据库

            try {
                // 提交事务
                connection.commit();
            } catch (SQLException e) {
                e.printStackTrace();
            } finally {
                try {
                    // 关闭连接
                    connection.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
        // 随着连接、资源的关闭，ThreadLocal对象也就没用了，【务必：关闭】（因为Tomcat服务器底层使用了线程池技术）
        conns.remove();
    }

    /**
     * 回滚事务，并关闭连接
     */
    public static void rollbackAndClose(){
        // 直接从ThreadLocal对象中获取连接，可能不存在
        Connection connection = conns.get();
        if (connection != null){ // 如果不等于null，说明之前使用过连接，操作过数据库

            try {
                // 回滚事务
                connection.rollback();
            } catch (SQLException e) {
                e.printStackTrace();
            } finally {
                try {
                    // 关闭连接
                    connection.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
        // 随着连接、资源的关闭，ThreadLocal对象也就没用了，【务必：关闭】（因为Tomcat服务器底层使用了线程池技术）
        conns.remove();
    }

    // 把关闭操作，放到回滚或提交中去了
//    /**
//     * 关闭连接，放回数据库连接池
//     * @param conn 要关闭的连接
//     */
//    public static void close(Connection conn){
//        try {
//            if (conn != null)
//                conn.close();
//        } catch (SQLException e) {
//            e.printStackTrace();
//        }
//    }
}
```



###### **修改 BaseDao**  

【主要修改：】

- 1、获取异常后，不再处理，向上抛
	- 【如果处理了，那后面怎么判断需不需要回滚数据？？】【因为异常已经被你处理了】
- 2、不再关闭连接
	- 【同样的道理，返回servlet层，判断是否需要回滚，然后关闭连接】
- 3、这种方法，要在servlet层 每个调用service层的代码前加上，try-catch【判断是不是需要回滚】
	- 下边有统一增加的方法，不用每个方法去增加try-catch

```java
package com.tianhao.dao.impl;

import com.tianhao.utils.JdbcUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

/**
 * @ClassName BaseDao
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/8 22:30
 * @Version 1.0
 */
public abstract class BaseDao {
    // 使用DbUtils 操作数据库
    private QueryRunner queryRunner = new QueryRunner();

    /**
     * update用来实现 insert/update/delete语句
     * @param sql sql语句
     * @param args 占位符
     * @return 如果返回-1，表示执行失败，否则返回受影响行数
     */
    public int update(String sql,Object ...args){
        Connection conn = JdbcUtils.getConnection();
        try {
            return queryRunner.update(conn,sql,args); // 返回受影响行数
        } catch (SQLException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }

    /**
     * 查询返回一个JavaBean的sql语句
     * @param type 返回对象类型
     * @param sql 执行的SQL语句
     * @param args 占位符，SQL语句的参数
     * @param <T> 返回的类型的泛型
     * @return
     */
    public <T> T queryForOne(Class<T> type,String sql,Object ...args){
        Connection conn = JdbcUtils.getConnection();
        try {
            return queryRunner.query(conn,sql,new BeanHandler<T>(type),args);
        } catch (SQLException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }


    /**
     * 查询多个结果，返回对象数组
     * @param type 返回对象类型
     * @param sql 执行的SQL语句
     * @param args 占位符，SQL语句的参数
     * @param <T> 返回的类型的泛型
     * @return
     */
    public <T> List<T> queryForList(Class<T> type,String sql,Object ...args){
        Connection conn = JdbcUtils.getConnection();
        try {
            return queryRunner.query(conn,sql,new BeanListHandler<T>(type),args);
        } catch (SQLException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }

    /**
     * 查询单个值，最大值、最小值、总行数之类的
     * @param sql
     * @param args
     * @return
     */
    public Object queryForSingleValue(String sql,Object ...args){
        Connection conn = JdbcUtils.getConnection();
        try {
            return queryRunner.query(conn,sql,new ScalarHandler(),args);
        } catch (SQLException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
}
```



##### 3.2、 使用 Filter 过滤器统一给所有的 Service 方法都加上 try-catch。 来进行实现的管理。

原理分析图：

![image-20211117201119790](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211117201029979.png)  

Filter 类代码：  

```java
package com.tianhao.filter; /**
 * @ClassName ${NAME}
 * @Description TODO:
 * @Author sth_199509@163.com
 * @Date 2021/11/17 22:05
 * @Version 1.0
 */

import com.tianhao.utils.JdbcUtils;

import javax.servlet.*;
import java.io.IOException;

public class TransactionFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {

        try {
            chain.doFilter(request, response);
            // 没有异常，提交事务
            JdbcUtils.commitAndClose();
        } catch (Exception e) {
            // 产生异常，回滚事务
            JdbcUtils.rollbackAndClose();
            e.printStackTrace();
            throw new RuntimeException(e);
            // 【处里完成之后】把异常抛给Toncat，让服务器来展示有好多错误页面
        }
    }
}
```



在 web.xml 中的配置：  

```xml
<filter>
    <filter-name>TransactionFilter</filter-name>
    <filter-class>com.tianhao.filter.TransactionFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>TransactionFilter</filter-name>
    <!--所有事务全部拦截-->
    <url-pattern>/*</url-pattern>
</filter-mapping>
```



抛异常！！！！！

<font color='red'>一定要记得把 BaseServlet 中的异常往外抛给 Filter 过滤器  </font>

<font color='blue'>Filter 过滤器的异常再抛，抛给Tomcat </font>



##### 3.3、 将所有异常都统一交给 Tomcat， 让 Tomcat 展示友好的错误信息页面。  

创建对应错误页面，然后再在xml配置【出错跳转】

![image-20211117232532444](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211117201119790.png)

在 web.xml 中我们可以通过错误页面配置来进行管理。  

```xml
<!--    error标签-->
    <error-page>
        <!--error-code：是错误类型-->
        <error-code>500</error-code>
        <!--location：标签表示要跳转的页面路径-->
        <location>/pages/error/error_500.jsp</location>
    </error-page>

    <error-page>
        <!--error-code：是错误类型-->
        <error-code>404</error-code>
        <!--location：标签表示要跳转的页面路径-->
        <location>/pages/error/error_404.jsp</location>
    </error-page>
```



## 21、使用AJAX 验证用户名是否可用

![image-20211118083704343](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211118083704343.png)



UserServlet 程序中 ajaxExistsUsername 方法：

```java
/**
 * 通过ajax 检查用户名是否存在
 * @param request
 * @param response
 * @return
 * @throws ServletException
 * @throws IOException
 */
protected void ajaxExistsUsername(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 1、获取请求参数
    String username = request.getParameter("username");
    // 2、调用userService.existsUsername()方法
    boolean isExists =  userService.existsUsername(username);
    // 3、把要返回的结果封装成map对象
    HashMap<String, Object> resultMap = new HashMap<>();
    resultMap.put("isExists",isExists);

    // 4、把map对象转换成json字符串
    Gson gson = new Gson();
    String resultJson = gson.toJson(resultMap);
    // 5、回传数据
    response.getWriter().write(resultJson);
}
```

regist.jsp 页面中的代码：  

```javascript
// 重中之重！！！页面加载之后
$(function (){


   // 给用户名输入框绑定失去焦点事件
   $("#username").blur(function () {
      // 1、获取用户名
      var username = this.value;// 这里不带括号就仅仅是value
      // $.getJSON(url,data,callback);
      $.getJSON("http://localhost:8080/Books/userServlet","action=ajaxExistsUsername&username="+username,function (data) {
         if (data.isExists){
            $("span.errorMsg").text("用户名已存在！");
         }else{
            $("span.errorMsg").text("用户名可用！");
         }
      });
   });
});
```

## 22、使用 AJAX 修改把商品添加到购物车

![image-20211118092816607](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211118092816607.png)

CartServlet 程序：  

```java
protected void ajaxAddItem(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 获取请求的参数，商品编号
    int id = WebUtils.parseInt(request.getParameter("id"),0);
    // 调用bookService.queryBookById(id);得到图书的信息
    Book book = bookService.queryBookById(id);
    // 把图书的信息，转换成为CartItem商品项
    CartItem cartItem = new CartItem(id, book.getName(), 1, book.getPrice(), book.getPrice());
    // 调用Cart.addItem(CartItem);添加商品
    Cart cart = (Cart)request.getSession().getAttribute("cart");
    // 防止每次添加，都换新的车，这里把车保存在Session会话中
    if (cart == null){
        cart = new Cart();
        request.getSession().setAttribute("cart",cart);
    }
    cart.addItem(cartItem);
// 上边都一样，就是把保存信息到session域和请求重定向更改了，改成下边代码
    
    // 通过json返回最后一个商品名称和购物车商品总数量
    HashMap<String, Object> resultMap = new HashMap<>();
    resultMap.put("totalCount",cart.getTotalCount());
    resultMap.put("lastName",cartItem.getName());

    Gson gson = new Gson();
    String resultMapString = gson.toJson(resultMap);
    response.getWriter().write(resultMapString);
}
```



pages/client/index.jsp 页面
html 代码：  【判断不需要了，就留两个空位置就行了】

```html
             <span id="cartTotalCount" ></span>
            <div>
               <span id="lastName" style="color: red"></span>
            </div>

<%--            &lt;%&ndash;购物车为空&ndash;%&gt;--%>
<%--            <c:if test="${empty sessionScope.cart.items}">--%>
<%--               <span></span>--%>
<%--               <div>--%>
<%--                  <span style="color: red">当前购物车为空</span>--%>
<%--               </div>--%>
<%--            </c:if>--%>
<%--            &lt;%&ndash;购物车不空&ndash;%&gt;--%>
<%--            <c:if test="${not empty sessionScope.cart.items}">--%>
<%--               <span id="cartTotalCount"${sessionScope.totalCount}></span>--%>
<%--               <div>--%>
<%--                  您刚刚将<span id="lastName" style="color: red">${sessionScope.last}</span>加入到了购物车中--%>
<%--               </div>--%>
<%--            </c:if>--%>
<%--         </div>--%>
```

javaScript 代码：  

```javascript
// 给【加入购物车】按钮添加单击事件
$("button.addToCart").click(function (){
   // this:当前响应事件的Dom对象【button按钮】
   // attr() 方法，设置或返回属性值
   var bookId = $(this).attr("bookId")
   // location.href = "http://localhost:8080/Books/cartServlet?action=addItem&id=" + bookId;
   // $.getJSON(url,data,callback);
   $.getJSON("http://localhost:8080/Books/cartServlet","action=ajaxAddItem&id=" + bookId,function (data) {
      $("#cartTotalCount").text("您的购物车中有" + data.totalCount + "件商品");
      $("#lastName").text("您刚刚将" + data.lastName + "加入到了购物车中");
   });

});
```

