# 面经

## 他人笔记

### 1

作者：https://blog.csdn.net/qq_41999455/article/details/91880444

### 2、说一下集合框架吧，了解哪些接口、类

list接口：存储不唯一的（可重复），有序的元素。
set接口：存储不可重复元素，无序的元素。
map接口：使用键值对进行存储元素。

### 3、list包含哪些类

常用的有LinkedList和ArrayList两个，（当时没记起来Vector和Stack）

### 4、能说一下LinkedList和ArrayList的区别是什么吗

两者都是不同步的，即线程不安全的。
从底层数据结构来讲，ArrayList是Object数组实现的，LinkedList是由双向链表构成的。
由数据结构实现可以得出，LinkedList不支持快速随机访问，后者是支持的。
存储所用的空间LinkedList更多一些，它需要存储前驱后继节点。

### 5、那两者谁的插入元素效率更高一些呢？

（当时紧张到说了句ArrayList。。。蠢哭自己了，连忙道歉）
是LinkedList，从它的底层数据结构就能看出来，LinkedList只需要断开链接即可，而ArrayList需要进行大量元素的移动后插入。

### 6、可以讲一下HashMap中的put方法的实现过程吗

（这道题也就是间接问你关于hashmap的数据结构了）
这得从它的底层数据结构说起，HashMap的是由数组+链表的结构实现的（当时忘了阈值超过8，演化为红黑树这一点了，面试完才想起来没说），它的内部封装了一个Entry数组，该数组也是一个哈希数组，故而存在哈希冲突的问题，HashMap是通过链地址法来解决冲突问题的，在每一个数组节点下封装一个单链表，所以put（）方法添加一个新元素时先通过计算该元素的hash值，再通过hash&（length-1）确定该元素在Entry数组中的下标位置，若无元素则添加，若存在元素再通过equals方法来判断该元素是否在该链表中，如果不存在则放在头结点位置，如存在则不添加。

### 7、当数组值达到峰值时，怎么进行扩展

hashmap中有两个构造参数，一个初始容量（默认16），另一个为加载因子（默认0.75），当当前存储大于初始容量与加载因子的乘积值时，则进行扩容操作，每次已二倍的速率增长，最大值为2*30（幂次）。
扩容是新建了一个数组，会重新计算hash来获取元素的新位置，所以扩容是一个相当耗时的操作。

### 8、数据库用的多不，说一下数据库

平时用MySQL比较多一些。

### 9、数据库优化有哪些方法（简历上写了。。）

（这一块不是很熟，答的不好）

选择合适的字段，尽量把字段设置为not null，这样查询就无需比较null值。
使用关键字查询（left、join、on）查询代替子查询。
使用union联合查询，手动创建临时表。
开启事务，当数据库执行多条语句出现错误时，事务会回滚，可以维护数据库完整性。
使用外键，事务可以维护数据的完整性，但不能保证数据的关联性，使用外键可以保证。
使用索引，索引是提高数据库性能的常用方法，特别是对于max、min、order by查询时。
优化查询语句的书写。

### 10、可以说一下事务吗

（竟然紧张到忘记说ACID了，直接说了事务隔离级别。。。蠢了）
ACID大家应该都清楚吧，原子性、一致性、隔离性、永久性。

隔离级别包括四个级别：

read_uncommited:最低隔离级别，允许读取未提交的数据，造成（脏读、幻读、不可重复读）
read_commited：允许读取已提交数据，阻止了脏读，但还存在幻读、不可重复读
repeatable_read：可重复读，多次读取结果一致，阻止脏读、不可重复读，但存在幻读
serializable：最高级别，服从ACID，依次执行，影响性能

### 11、脏读是什么？幻读是什么？

脏读：发生在一个事务A读取了被另一个事务B修改，但是还未提交的数据。假如B回退，则事务A读取的是无效的数据。

幻读 ：幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。

### 12、数据库索引的数据结构是怎样的？

索引的数据结构包含B+树和哈希表两种。一般用B+树比较多（接下来就是无限的B+树怒怼环节了，晕）

### 13、说一下B+树的定义吧

读者可以自行百度查看。推荐阅读(https://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html)

B+树是B树的一种变形。
B树定义：
M表示阶数。

多路搜索树，不是二叉的。
根节点至少有两个子节点【2，M】
除根节点以外的非叶子结点的儿子数是【M/2,M】
每个节点至少存放 M/2-1（取上整）和至多M-1个关键字。（至少两个）
非叶子结点的关键字个数：指向儿子的指针数 + 1
所有的叶子结点在同一层
B树特点：

任何一个关键字仅出现在一个结点中
搜索有可能在非叶子结点结束
其性能相当于在关键字全集内做一次二分查找
一棵m阶的B+树和m阶的B-树的差异在于：

有k个子结点的结点必然有k个关键码；
非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。
B+树的特点：
关键字在叶子结点中，并且有序。
不可能在非叶子结点命中。
非叶子结点相当于索引，叶子结点相当于存储层。
更适合文件索引系统。

### 14、为什么使用B+树做索引的数据结构，优势在哪里

（这一部分不太懂，当时疯狂说深度低，二叉顺序访问之类的。。。面试官引导磁盘访问效率和内存访问效率时间量级问题，我也很晕菜啊。。。下来百度学习了一下）
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。

磁盘存取原理：
索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的，一般是毫秒级别，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存

B+树的优点：

由于B+树在内部节点上不含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。
B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

### 15、说一下网络七层模型

（当时只记起来五层模型。。。）
七层模型：
物理层—数据链路层—网络层—传输层—会话层—表示层—应用层
五层模型：
物理层—数据链路层—网络层—传输层—应用层

### 16、说一下TCP的三次握手和四次挥手

三次握手：

客户端发送一个SYN请求连接，服务端收到连接请求
服务端收到请求之后返回一个ACK的确认请求和SYN
客户端收到之后再次发送一个ACK的确认码
四次挥手：（可以理解为三次挥手+半关闭）
终止连接一般是由客户端发起的。

客户端发送一个FIN断开连接请求
服务端收到该请求之后，先返回一个ACK的确认码
等待服务端当前正在传输的数据传输完成之后，服务端发送一个FIN的终止连接请求
客户端接受到服务端请求之后，给服务端返回一个ACK的确认码，至此终止连接完成

### 17、如何理解TIME-WAIT

（当时把TIME-WAIT和停止等待协议弄混了。。。说了半天ARQ）

TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证。

可以理解为主动关闭连接的一方，要停留在TIME-WAIT状态，等待2*MSL（4分钟，Centos7上默认配置的值是1分钟）时间才可以再次回到CLOSED状态，在等待期间该端口（socket）不能被回收使用，即不能正常连接请求。具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的socket， 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力，甚至耗尽可用的socket，停止服务。

### 18、说一下Spring的IOC和AOP

IOC:控制反转，是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。

AOP:面向切面编程,能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

### 19、AOP是如何实现的？

AOP是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理。

### 20、cglib代理怎么实现？

CGlib是一个字节码增强库，为AOP等提供了底层支持。

通过实现MethodInterceptor接口，重写其中的Intercept方法（拦截器）

### 21、SpringMVC的请求过程

（1）客户端（浏览器）发送请求，直接请求到 DispatcherServlet。

（2）DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。

（3）解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。

（4）HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑。

（5）处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。

（6）ViewResolver 会根据逻辑 View 查找实际的 View。

（7）DispaterServlet 把返回的 Model 传给 View（视图渲染）。

（8）把 View 返回给请求者（浏览器）

### 22、说说IO吧

一些基本的输入输出流介绍。

### 23、NIO是同步阻塞的吗？还有什么阻塞？

它是同步非阻塞的，还有异步非阻塞的ＡＩＯ；

NIO的特性/NIO和IO的区别
IO流是阻塞的，NIO不是阻塞的；
也就意味着在读写数据期间，IO流的线程是被阻塞的，不能去干其他事情，而NIO是可以进行非阻塞的IO操作的，单线程中从通道（双向通道，可读可写）读取数据到buffer，同时继续做别的事情，当数据读到buffer中之后再去继续执行数据的操作；
IO是面向流的，NIO是面向缓冲区的；
Buffer是一个对象，它包含了你要读取和写入的数据，在NIO库中，所有数据都是由缓冲区处理的。在读取数据时是读到缓冲区的，在写入数据时是写到缓冲区的。任何时候访问NIO的数据都是需要通过缓冲区操作的；
NIO是有选择器的，IO是没有的；
选择器用于单线程处理多个通道。因此它需要较少的线程来处理这些通道，线程之间的切换时昂贵的，为了提高效率选择器是很有用的；



## 自己笔记

## 面试准备

### Java基础

#### 1、== 操作符和 equals（）的区别

​		**==：是一个运算符**

​				1、可以使用在基本数据类型变量和引用数据类型变量中

​				2、如果比较的是基本数据类型变量，比较两个变量保存的数据，是否相等，（不一定类型相同）

​				3、如果比较的是引用数据类型变量，比较两个对象的地址值，是否相等。



​		**equals（）：是一个方法**

​				1、A.equals（B）,返回true或者false

​				2、只能够适用于引用数据类型

​				3、Object类中equals（）方法的定义：

```java
public boolean equals(Object obj) {
    return (this == obj);
}
//此时表明：在Object类中定义的equals()方法和“==”运算符的作用是相同的；
```

​				4、像String、Data、File、包装类等，都重写了Object类中的equals（）方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的 ”实体内容“ 是否相同。

​				5、通常情况下，我们自定义的类如果使用equals（）的话，也通常是比较两个对象的 “实体内容”，是否相同，那么我们就需要重写Object类中的equals（）方法。



#### 2、包装类

​		①下面两段代码输出的结果是否相同，若不同则分别说出输出什么内容

​		**主要考察：**Object o1 = true ? new Integer(1) : new Double(2.0);编译时会进行自动类型提升Integer--->Double

```java
import org.junit.Test;
//第一段代码
public class InterviewTest {
    @Test
    public void test1(){
        Object o1 = true ? new Integer(1) : new Double(2.0);
        System.out.println(o1);//1.0
        //因为编译阶段Integer类型被自动类型提升为Double类型
    }

//第二段代码
    @Test
    public void test2(){
        Object o2;
        if(true)
            o2 = new Integer(1);
        else
            o2 = new Double(2.0);
        System.out.println(o2);//1
        //正常执行
    }
}
```

​		

​		②请说出下面三段代码的输出内容

​		**主要考察：**Integer内部定义了IntegerCache结构,IntegerCache中定义了Integer[]类型的名为cache[]的数组， 数组中存储了-128~127范围的整数，因为使用频繁，相当于提前缓存（cache），提高效率，当给Integer赋值的范围在-128~127范围内时，可以直接使用数组中元素，不用再去new了，所以返回地址值相同。

```java
import org.junit.Test;

public class InterviewTest {
    @Test
    public void test3(){
        Integer i = new Integer(1);
        Integer j = new Integer(1);
        System.out.println(i == j);//false
        //因为操作符==比较两个对象的地址值，必然不同，返回false

        Integer m = 1;
        Integer n = 1;
        System.out.println(m == n);//true
        //此时采用自动装箱
        //Integer内部定义了IntegerCache()结构,IntegerCache中定义了Integer[]类型的名为cache[]的数组，
        // 数组中存储了-128~127范围的整数，因为使用频繁，相当于提前缓存（cache），提高效率
        // 给Integer赋值的范围在-128~127范围内时，可以直接使用数组中元素，不用再去new了，
        //此时m和n定义为1，地址值均为cache[]数组中1的地址值，所以返回true

        Integer x = 128;
        Integer y = 128;
        System.out.println(x == y);
        //因为128不在cache[]数组范围之内，所以每次new了一个新的对象，故地址不同，返回false
    }
}
```



#### 3、单例模式（Singleton）

​		**设计模式：**是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像经典的棋谱，不同的棋局我们用不同的棋谱，免得我们自己再去思考和摸索。

​		**单利设计模式：**就是采取一定的方法保证在整个的软件系统中，**对某个类只能存在一个对象实例**，并且该类只提供一个取得对象实例的方法。如果我们要让类在虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类的内部仍可以产生该类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类的对象的变量也必须定义成静态的。

​		**单例模式的优点：**由于单例模式只生成一个实例，减少了系统性能的开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时、则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。

​		**单例设计模式： **    **饿汉式** VS **懒汉式**

​				饿汉式：直接创建对象，使用时调用；

​								坏处：对象加载时间过长。

​								好处：饿汉式是线程安全的。

​				懒汉式：暂不创建，使用时创建；

​								好处：延迟对象的创建。

​								坏处：需要考虑线程不安全问题，多线程时同时满足instance == null，同时进入if语句，创建多个对象。

```java
//饿汉式

//测试
public class Singleton_hungry {
    public static void main(String[] args){
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();
    }
}

class Singleton{
    private Singleton(){

    }
    private static Singleton instance = new Singleton();

    public static Singleton getInstance(){
        return instance;
    }
   
}
```



```java
//懒汉式
//测试
public class Singleton_lazy {
    public static void main(String[] args){
        Singleton_2 s1 = Singleton_2.getInstance();
        Singleton_2 s2 = Singleton_2.getInstance();
        if(s1 == s2)
            System.out.println(true);
    }
}
//直接锁方法----和-----同步代码块把方法内部全包起来一样。
//效率不高，并发性低，除了第一个new对象时，需要线程锁【单线程】之外
//已经new了对象之后，剩余的进来取对象，谁来谁取，根本不用等，而这种写法是任何时候到要等。
class Singleton_2{
    private Singleton_2(){}
    private static Singleton_2 instance = null;

    public static synchronized Singleton_2 getInstance() {
        if(instance == null){
        	instance = new Singleton_2();   
        }
        return instance;
    }
}


//双重检查锁
//这种方法在第一个new对象之后，剩余的取对象线程在第一个if语句！=null时，直接return取走对象，根本不涉及线程锁，只有第一个会判断两遍，然后进锁，new对象
class Singleton_2{
    private Singleton_2(){}
    private static Singleton_2 instance = null;

    public static Singleton_2 getInstance() {
        if(instance == null){
            synchronized(Singleton_2.class){ 
                if(instance == null){//这个if是为了第一次new对象时，第一个if满足条件进来多个线程，等拿到锁的线程new完后，将其他已经来的线程筛选出去，不满足第二个if
                    instance = new Singleton_2();
                }
            }
        }
        return instance;
    }
}
```

####      4、排错题

##### 1、调用方法输出X值时，不能区分是哪个X，因为接口和类是平级的。

```java
interface A {
    int x = 0;
}

class B{
    int x = 1;
}

class C extends B implements A {
    public void pX(){
        //编译不通过，X值不明确
        System.out.println(x);
        
//        System.out.println(super.x);  //调用父类x值，若多层父类，默认就近原则
//        System.out.println(A.x);  //调用接口中的x值，因为接口中的常量为全局常量，直接调用即可
    }

    public static void main(String[] args){
        new C().pX();
    }
}
```

##### 2、接口中定义类型：

​						>全局常量：public static final 的，（但是书写时，可以不写，直接写 int、double等）

​						>抽象方法：public abstract 的                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

```java
public class Ball implements Rollable{
    private String name;

    public String getName(){
        return name;
    }

    public Ball(String name){
        this.name = name;
    }

    public void play(){//因为接口Playable、Bounceable中的play()方法重名，此处重写一个play()也可以

        //ball虽然在Rollable中定义了类型，但是接口中变量隐藏了public static final，
        //方法隐藏了public abstract。
        //因为有final 所以此处的ball不允许再赋值或赋对象
        ball = new Ball("Football");//错！！！！！！！！！！！！！
        System.out.println(ball.getName());
    }
}

interface Playable{
    void play();
}
interface Bounceable{
    void play();
}
interface Rollable extends Playable,Bounceable{
    Ball ball = new Ball("PingPang");
//    public static final Ball ball = new Ball("PingPang");
}
```



#### 5、常见的异常有哪些？请举例说明：

> 运行时异常
>
> ```java
> //NullPointerException空指针异常
> 
> public void test1(){
>  //举例一
>  int[] arr = null;
>  System.out.println(arr[1]);
> 
>  //举例二
>  String str = null;
>  System.out.println(str.charAt(0));
> }
> ```

```java
//IndexOutOfBoundsException角标越界

public void test2(){
    //举例一:ArrayIndexOutOfBoundsException数组角标越界
    int[] arr = new int[3];
    System.out.println(arr[99]);

    //举例二:StringIndexOutOfBoundsException字符串角标越界
    String str = "abcd";
    System.out.println(str.charAt(99));
}
```

```java
//ClassCastException类型转换异常

public void test3(){
    Object obj = new Date();
    String str = (String)obj;
}
```

```java
//NumberFormatException数字格式异常

public void test4(){
    String str = "12345";//正常
    str = "abc";
    int num = Integer.parseInt(str);
}
```

```java
//InputMismatchException输入不匹配异常

public void test5(){
    Scanner scan = new Scanner(System.in);
    //若输入数据不是int类型，则报出异常
    int score = scan.nextInt();
    System.out.println(score);
}
```

```java
//ArithmeticException算数异常

public void test6(){
    int a = 10;
    int b = 0;
    System.out.println(a / b);
}
```

#### 6、throw和throws

throws属于异常处理的一种方式，声明在方法体外。

​				放在A方法后边，声明A方法可能要抛出的异常类，将异常向上汇报，反馈至调用者。

throw表示抛出一个异常类的对象，是生成异常对象的过程。声明在方法体内。

```java
public static double ecm(int a, int b) throws EcDef {		//throws
    if (a < 0 || b < 0) {
        throw new EcDef("请勿输入负数！");						//throw
    }
    return a / b;
}
//EcDef是自定义的异常类型
```



#### 7、synchronized 与 lock的异同？？？

> 答：1、Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放
>
> ​		2、Lock只有代码块锁，synchronized有代码块锁和方法锁
>
> ​		3、使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供了更多的子类）
>
> ​		相同：二者都可以解决线程安全问题
>
> ​		不同：synchronized 机制在执行完相应的同步代码以后，自动释放同步监视器（锁）
>
> ​					lock需要手动的启动同步（lock（）方法），同时结束同步也需要手动实现（unlock（）方法）。
>
> 优先使用顺序：Lock------->同步代码块（已经进入了方法体，分配了相应的资源）------->同步方法（在方法体之外）

#### 8、如何解决线程安全问题？有几种方式？

```java
方式一：同步代码块
synchronized(同步监视器){
    //需要被同步的代码(别包多了代码，成单线程了)
}

方式二：同步方法
synchronized 方法名(){//默认同步监视器就是this

}

方式三：Lock锁----JDK5.0新增
import java.util.concurrent.locks.ReentrantLock;//导包
private ReentrantLock lock = new ReentrantLock();//在run方法上边创建对象
        try {
           
            lock.lock();//手动上锁
            
            //同步代码块
        
        }finally {
            lock.unlock();//手动开锁
        }
```

* **方式一：同步代码块**

* 1、需要被同步的代码    (别包多了代码，成单线程了)------即操作共享数据的代码

* 2、共享数据：多个线程共同操作的变量---如100张票

* 3、同步监视器（就是锁）：任何一个类的对象都有可以充当一个锁Object类也可以

* **要求：多个线程必须要共用同一把锁。**

* 4、在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当监视器。

* 5、在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。

  

* **方式二：同步方法**

* 如果操作共享数据的代码完整个的声明在一个方法中，我们不妨将此方法声明成同步的

* 1、同步方法仍然涉及到同步监视器，只是不需要我们显式的声明

* 2、非静态的同步方法，同步监视器是：this

* 3、静态的同步方法，同步监视器是：当前类本身。（主要是继承Thread类创建多线程，因为继承Thread类要创建多个对象，通过设置方法为static静态的，形成一把锁的效果）

​	

* **方式三：Lock锁----JDK5.0新增**

* 手动开启和关闭锁

#### 9、sleep() 和 wait() 的异同？？？

> 1、相同点：一旦执行方法，都可以是的当前的线程进入阻塞状态。
>
> 2、不同点：①两个方法声明的位置不同：Thread类中声明sleep（），Object类中声明wait（）
>
> ​					 ②调用要求不同：sleep（）可以在任何需要的场景下调用。wait（）必须使用在同步代码块或同步方法中
>
> ​					 ③关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中时，sleep（）不会释放锁，wait（）会释放锁

#### 10、String str = new String("abc");方式创建对象，在内存中创建了几个对象？

> 答：两个：一个是堆空间中new结构创建的对象，另一个是char[]对象的常量池中的数据：abc

![image-20210918225600492](https://pledge99.oss-cn-beijing.aliyuncs.com/img/image-20211004220250508-163335617173112.png)

#### 11、下列程序运行结果

##### 		1、输出结果：good and best

```java
public class StringTest {
    String str = new String("good");
    char[] ch = { 't', 'e', 's', 't' };
    public void change(String str, char ch[]) {
        str = "test ok";
        ch[0] = 'b';
    }
    public static void main(String[] args) {
        StringTest ex = new StringTest();
        ex.change(ex.str, ex.ch);
        System.out.print(ex.str + " and ");
        System.out.println(ex.ch);
        //输出结果：good and best
    }
}
```

##### 	2、增强for循环

```java
@Test
public void test3(){
    String[] str = new String[5];
    for (String s : str) {
        s = "钢蛋";
        System.out.println(s);//相当于原for循环，你把i的值改了，不影响原数组
    }
    
    
    for (int i = 0; i < str.length; i++) {
        System.out.println(str[i]);
    }
}
----------------------
钢蛋
钢蛋
钢蛋
钢蛋
钢蛋
null
null
null
null
null
```

##### 	3、List的remove()方法

remove可以按索引移除，还可以按对象移除



```java
@Test
public void testListRemove() {
    List list = new ArrayList();
    list.add(1);
    list.add(2);
    list.add(3);
    updateList(list);
    System.out.println(list);//1，2
}
private static void updateList(List list) {
    list.remove(2);//按索引，将3移除
    list.remove(new Integer(2));//按对象移除，将2移除
}
```

##### 4、Set接口理解

其中Person类中重写了hashCode()和equal()方法

```java
HashSet set = new HashSet();
Person p1 = new Person(1001,"AA");
Person p2 = new Person(1002,"BB");
set.add(p1);
set.add(p2);

p1.name = "CC";
set.remove(p1);
System.out.println(set);
//[Person{age=1002, name='BB'}, Person{age=1001, name='CC'}]
//并没有移除p1，为什么？？
//因为remove方法去查找p1时，按照name == CC去找到，肯定找不到，因为p1时按照AA哈希值存的

set.add(new Person(1001,"CC"));
System.out.println(set);
//[Person{age=1002, name='BB'}, Person{age=1001, name='CC'}, Person{age=1001, name='CC'}]
//同名的添加成功了，为什么？？
//跟上边一个道理，原有的name == CC存放的时name == AA的哈希地址，
//添加操作时name == CC哈希地址处为空，自然添加成功

set.add(new Person(1001,"AA"));
System.out.println(set);
//[Person{age=1002, name='BB'}, Person{age=1001, name='CC'}, Person{age=1001, name='CC'}, Person{age=1001, name='AA'}]
//那为什么name == AA的哈希地址位置占着，还能添加成功？？？？
//哈希地址判断不空，此时equals比较属性，因为AA和CC不同，默认为是两个对象，通过链表在同一个哈希地址后边增加

```



#### 12、String、StringBuffer、StringBuilder三者有何异同？

String：不可变的字符序列，底层结构使用char[]数组存储

StringBuffer：可变的字符序列，线程安全的，效率偏低；底层结构使用char[]数组存储

StringBuilder：可变的字符序列，JDK5.0新增，线程不安全，效率高些；底层结构使用char[]数组存储

**源码分析：**

```java
String str = new String();  
//char[] value = new value[0];
String str1 = new String("abc");    
//char[] value = new value[]{'a','b','c'};

StringBuffer sbf = new StringBuffer();  
//char[] value = new value[16];底层创建了一个长度为16的空数组
StringBuffer sbf2 = new StringBuffer("abc");  
//char[] value = new value["abc".length() + 16];底层创建了一个长度为3加16的空数组

sbf.append('a');//value[0] = 'a';
sbf.append('b');//value[1] = 'b';

    
```

**问题一：**sbf2.length()是多少？
    	      答：3，因为源码重写了length()方法。
**问题二：**扩容问题，如果要添加的数据底层数组装不下了，那就要扩容底层数组。
		      默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中。

**指导意义：**在开发中尽可能使用StringBuffer(int capacity)  或者 StringBuilder(int capacity)，可预见的情况下，直接定义数组长度capacity

#### 13、“三天打鱼两天晒网”？

渔夫在1888-01-01日开始打鱼，问2021-09-09日   在打鱼？还是晒网？

```java
@Test
public void practice2() throws ParseException {
    String start = "1988-01-03";
    String end = "2021-09-09";
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date dateStart = simpleDateFormat.parse(start);
    Date dateEnd = simpleDateFormat.parse(end);
    
    long day = (dateEnd.getTime() - dateStart.getTime())/(24 * 60 * 60 * 1000);
    long remainder = (dateEnd.getTime() - dateStart.getTime()) % (24 * 60 * 60 * 1000);
    if (remainder != 0) day += 1;

    if (day % 5 == 1 || day % 5 == 2 || day % 5 == 3){
        System.out.println("正在打鱼");
    }else{
        System.out.println("正在晒网");
    }

}
```



#### 14、线程通信的经典例题（生产者/消费者问题）

生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品，店员一次只能持有固定数量的产品（比如20个），如果生产者试图生产更多产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。

分析：

> 1、是否是多线程问题？是！生产者线程、消费者线程

> 2、是否有共享数据？有！店员（产品数量）

> 3、如何解决线程安全问题？同步机制，有三种方法

> 4、是否涉及到线程通信？是

```java
public class Clerk{//真正的同步代码段，下边两个类只是为了调用。

    private int productCount = 0;

    //消费产品
    public synchronized void coustomerProductor() {

        if (productCount > 0){
            System.out.println(Thread.currentThread().getName() + ":开始消费第" + productCount + "个产品");
            productCount--;
            notify();//生产者阻塞时，是产品满了，此时只要消费一个productCount--就可以notify唤醒
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    //生产产品
    public synchronized void producerProductor() {

        if (productCount < 20){
            productCount++;
            System.out.println(Thread.currentThread().getName() + ":开始生产第" + productCount + "个产品");
            notify();//消费者阻塞时，是产品卖没了，此时只要生产一个productCount++就可以notify唤醒
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Productor implements Runnable{//生产者

    private Clerk clerk ;

    public Productor(Clerk clerk){
        this.clerk = clerk;
    }

    @Override
    public void run(){
        System.out.println("开始生产产品。。。。");

        while(true){
            try{
                Thread.sleep(1);
            }catch(InterruptedException e){
                e.printStackTrace();
            }

            clerk.producerProductor();
        }
    }
}

class Customer implements Runnable{
    private Clerk clerk ;

    public Customer(Clerk clerk){
        this.clerk = clerk;
    }

    @Override
    public void run(){
        System.out.println("开始消费产品。。。。");

        while(true){
            try{
                Thread.sleep(10);
            }catch(InterruptedException e){
                e.printStackTrace();
            }

            clerk.coustomerProductor();
        }
    }
}
```



```java
public class ShopTest {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();

        Thread p = new Thread(new Productor(clerk));
        Thread c = new Thread(new Customer(clerk));

        p.setName("生产者");
        c.setName("消费者");

        p.start();
        c.start();
    }
}
```



#### 15、ArrayList、LinkedList、Vector三者的异同？

**请问ArrayList/LinkedList/Vector的异同？ 谈谈你的理解？ ArrayList底层是什么？扩容机制？ Vector和ArrayList的最大区别?**  

**答：**

> **ArrayList和LinkedList的异同**
> 二者都线程不安全，相对线程安全的Vector，执行效率高。
> 此外， ArrayList是实现了基于动态数组的数据结构， LinkedList基于链表的数据结构。对于随机访问get和set， ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove， LinkedList比较占优势，因为ArrayList要移动数据。\
> **ArrayList和Vector的区别**
> Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。 Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。 Vector还有一个子类Stack。  





**相同点：**三个类都是实现了List接口，存储数据的特点相同：都是存储有序的，可重复的数据

**不同点：**

​			ArrayList：作为List接口的主要实现类，线程不安全的，效率高；底层使用Object[] elementData存储

​			LinkedList：底层使用双向链表存储：对于频繁的插入、删除操作，此类效率比ArrayList高

​			Vector：作为List接口的古老实现类；线程安全的，效率低，底层使用Object[] elementData存储

**源码分析：**

**ArrayList：**

> JDK7情况下：
>
> ```java
> ArrayList list = new ArrayList();	//底层创建了长度为10的Object[]数组elementData
> List.add(123);//elementData[0] = new Integer(123);
> ...
> List.add(11);//添加超过10个，导致底层elementData[]数组容量不够，进行扩容。
> //默认情况下，扩容为原来容量的1.5倍，同时将原有数组中的数据复制到新的数组中。
> 
> //结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity);
> //直接确定第一次创建的底层数组大小
> ```

> JDK8情况下：【先不创建数组，第一次添加操作时再创建】
>
> ```java
> ArrayList list = new ArrayList();	//底层Object[]数组elementData初始化为{}，并没有创建数组
> List.add(123);//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData数组中
> //后续操作与JDK7一致
> ```

总结：JDK7中的ArrayList的对象的创建类似于单例模式中的饿汉式，而JDK8中的ArrayList的对象的创建类似于单例模式中的懒汉式，延迟了数组的创建，节省内存。



**LinkedList：**

> ```java
> @Test
> public void test4(){
>  LinkedList linkedList = new LinkedList();//内部声明了Node类型的first和last属性，默认值为null
>  linkedList.add(123);//将123封装到Node中，创建了Node对象。
> 
> }
> ```
>
> ```java
> //Node源码：体现了LinkedList的双向链表的说法
> private static class Node<E> {
>  E item;
>  LinkedList.Node<E> next;
>  LinkedList.Node<E> prev;
> 
>  Node(LinkedList.Node<E> prev, E element, LinkedList.Node<E> next) {
>      this.item = element;
>      this.next = next;
>      this.prev = prev;
>  }
> }
> ```



**Vector：**

> 对象之初就创建长度为10的底层数组，添加操作扩容时是原数组的2倍。



#### 16、集合Collection中存储自定义对象时，要重写哪个方法？

问：集合Collection中存储自定义对象时，要自定义类重写哪个方法？为什么？

答：equals()方法

List接口：重写equals()方法

Set接口：HashSet类、LinkedHashSet类：重写equals()、hashCode()方法

​				 TreeSet类：自然排序时（Comparable）：重写comparTo（Object obj）

​									   定制排序时（Comparator）：重写compare（Object o1，Object o2）



#### 17、说说HashMap的底层实现原理？？

**以JDK7为例：**

```java
HashMap map = new HashMap();
```

在实例化以后，底层创建了长度为16的一维数组Entry[] table

```java
map.put(key,value);
....//添加许多元素以后
map.put(key1,value1);
```

添加操作，首先调用key1所在类的hashCode()计算key1的哈希值，得到在Entry数组中存放的位置。

- 情况一：如果此位置上数据为空，此时的key1-value1添加成功

- 情况二：如果此位置上数据不为空，（意味着此位置上存在一个或多个数据【以链表的形式存在】），此时比较key1和已经存在的一个或多个数据的哈希值：

  - 1、如果key1的哈希值与已经存在的数据的哈希值都不同，此时key1-value1添加成功
  - 2、如果key1的哈希值与已经存在的某个数据（key2）的哈希值相同，继续比较：调用key1所在类的equals（key2）和key2比较
    - 2.1如果equals()返回false：此时key1-value1添加成功
    - 2.2如果equals()返回true：则使用value1替换key2的value2,。

  **补充：**关于情况1和2.1，此时key1-value1和原来的数据以链表的方式存储。

  **扩容：**在不断添加过程中，当超出临界值且要存放位置非空时，会涉及到扩容的问题，默认的扩容方式是：扩容为原来容量的2倍，并将原有的数据复制过来。

**JDK8中的改变**

1、new HashMap()	时，底层没有创建一个长度为16的数组。

2、JDK8底层数组是：Node[]，而非Entry[]。

3、首次调用put()方法时，底层创建长度为16的数组。

4、JDK7底层结构只有：数组＋链表。JDK8中地层结构增加了红黑树：**数组＋链表＋红黑树**。

​	  当数组的某一索引位置上的元素是以链表形式存在的数据个数 > 8时，且当前数组的长度 > 64时，

​	  此时索引位置上的所有数据改为使用红黑树存储。【就是同一哈希地址值上元素大于8个时，用红黑树存，好找】



#### 18、说说HashMap和Hashtable的异同？？

**HashMap:**作为Map接口的主要实现类：线程不安全的，效率高；存储null的key和value

**Hashtable:**作为古老的实现类；线程安全的，效率低；不能存储null的key和value



#### 19、**那么HashMap什么时候进行扩容呢？【JDK 7】**

当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size) × loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75， 这是一个折中的取值。 也就是说， 默认情况下， **数组大小(DEFAULT_INITIAL_CAPACITY)为16， 那么当HashMap中元素个数超过16×0.75=12（这个值就是代码中的threshold值， 也叫做临界值） 的时候， 就把数组的大小扩展为 2×16=32， 即扩大一倍**， 然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作， 所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。  

#### 20、那么HashMap什么时候进行扩容和树形化呢【JDK 8】？

当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size) × loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75， 这是一个折中的取值。 也就是说， 默认
情况下， 数组大小(DEFAULT_INITIAL_CAPACITY)为16， **那么当HashMap中元素个数超过16 × 0.75=12（这个值就是代码中的threshold值， 也叫做临界值）的时候， 就把数组的大小扩展为 2 × 16=32， 即扩大一倍，** 然后重新计算每个元素在数组中的位置， 而这是一个非常消耗性能的操作， 所以如果我们已经预知HashMap中元素的个数， 那么预设元素的个数能够有效的提高HashMap的性能。**当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，**结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。  

#### 21、关于映射关系的key是否可以修改？ 

**答：不要修改**

映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。

#### 22、负载因子值的大小，对HashMap有什么影响

1、负载因子的大小决定了HashMap的数据密度。

2、负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。

3、负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建
议初始化预设大一点的空间。

4、按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。    

#### 23、Collection 和 Collections的区别？

Collection是接口，

Collections是工具类

#### 24、Map常用的实现类结构？？

Map：双列数据，存储key-value对数据，类似函数y = f（x）

- **HashMap:**作为Map接口的主要实现类：线程不安全的，效率高；存储null的key和value
  - **LinkedHashMap:**保证在遍历map元素时，可以按照添加顺序实现遍历，

​							原因：在原有的HashMap底层结构基础上，添加了一对指针，指向一个前一个后

​							对于频繁的遍历操作，此类执行效率高于HashMap

- **TreeMap:**保证按照添加的key-value对进行排序，实现排序遍历，此时使用key进行排序底层层使用红黑树
- **Hashtable:**作为古老的实现类；线程安全的，效率低；不能存储null的key和value
  - **properties: **常用来处理配置文件，key和value都是String类型





**HashMap的底层：**数组＋链表（JDK7及以前）

​								数组＋链表＋红黑树（JDK8）

#### 25、自定义类-----实现Scanner类的功能

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class MyInput {

    //Read a string from the keyboard
    public static String readString(){
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        //Get a string from the keyboard
        String str = null;
        try {
            str = br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        //Return the string obtained from the keyboard
        return str;
    }

    //Read an int value from the keyboard
    public static int readInt(){
        return Integer.parseInt(readString());
    }
    //Read a double value from the keyboard
    public static double readDouble(){
        return Double.parseDouble(readString());
    }
    //Read a float value from the keyboard
    public static float readFloat(){
        return Float.parseFloat(readString());
    }
    //Read a byte value from the keyboard
    public static byte readByte(){
        return Byte.parseByte(readString());
    }
    //Read a short value from the keyboard
    public static short readShort(){
        return Short.parseShort(readString());
    }
    //Read a long value from the keyboard
    public static long readLong(){
        return Long.parseLong(readString());
    }
    //Read an boolean value from the keyboard
    public static boolean readBoolean(){
        return Boolean.parseBoolean(readString());
    }
}
```



#### 26、谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化，是空方法接口，还有其它认识吗？  

- 实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。 <font color='red'>**这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。**</font> 换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。
- 由于大部分作为参数的类如String、 Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。  

#### 28、Statement与PreparedStatement的区别？？

- Preparedstatement是预处理过的，对于批量处理可以大大提高效率
- 数据库只进行一次处理时，用Statement对象进行处理，Preparedstatement开销比Statement大，对于一次性操作无好处
- Statement每次执行SQL语句时，相关数据库都要执行SQL的编译，PrepareStatement是预编译的，支持批处理
- Preparedstatement对象可以防止SQL注入更加安全。

#### 29、JVM 的类加载机制

JVM 的类加载机制是指 JVM 把描述类的数据从 .class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是 JVM 的类加载机制。

**类加载的生命周期**
类的生命周期总共分为7个阶段：加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备、解析三个步骤又可统称为连接。
加载、验证、准备、初始化和卸载五个步骤的顺序都是确定的，解析阶段在某些情况下有可能发生在初始化之后，这是为了支持 Java 语言的运行期绑定的特性。
在 JVM 虚拟机规范中并没有规定加载的时机，但是却规定了初始化的时机，而加载、验证、准备三个步骤是在初始化之前。
![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/1766810-20190816201824329-1954253596.png)
**类加载器**
一般分为启动类加载器（Bootstrap ClassLoader），扩展类加载器（Extension ClassLoader），应用程序类加载器（Application ClassLoader）
**双亲委派机制**
![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/1766810-20190816201840897-916163279.png)
上图所示的这种关系我们就称之类加载器的双亲委派模型。在双亲委派模型中，除了顶层的 Bootstrap ClassLoader 之外，其他的类加载器都有自己的父加载器。
双亲委派模型的工作流程：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，只有当父类加载器无法完成这个类加载请求时，才会让子类加载器去处理这个请求。

#### 30、红黑树有哪些性质？

一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：
1）每个结点要么是红的，要么是黑的。
2）根结点是黑的。
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。
4）如果一个结点是红的，那么它的俩个儿子都是黑的。
5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。

#### **1.介绍一下 java 吧**

java 是一门**「开源的跨平台的面向对象的」**计算机语言.

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-4eb62ebcbaa287ca3eaaca830f40607a_1440w.jpg)

跨平台是因为 java 的 class 文件是运行在虚拟机上的,其实跨平台的,而**「虚拟机是不同平台有不同版本」**,所以说 java 是跨平台的.

面向对象有几个特点:

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-c657272bf6b60fb7c677759e18a380b6_1440w.jpg)



- - 1.**「封装」**

  - - 两层含义：一层含义是把对象的属性和行为看成一个密不可分的整体，将这两者'封装'在一个不可分割的**「独立单元」**(即对象)中
    - 另一层含义指'信息隐藏，把不需要让外界知道的信息隐藏起来，有些对象的属性及行为允许外界用户知道或使用，但不允许更改，而另一些属性或行为，则不允许外界知晓，或只允许使用对象的功能，而尽可能**「隐藏对象的功能实现细节」**。

**「优点」**:

> 1.良好的封装能够**「减少耦合」**，符合程序设计追求'高内聚，低耦合'
> 2.**「类内部的结构可以自由修改」**
> 3.可以对成员变量进行更**「精确的控制」**
> 4.**「隐藏信息」**实现细节

- - 2.**「继承」**

  - - 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

**「优点」**:

> 1.提高类代码的**「复用性」**
> 2.提高了代码的**「维护性」**

- - 3.**「多态」**

  - - 1.**「方法重载」**：在一个类中，允许多个方法使用同一个名字，但方法的参数不同，完成的功能也不同。
    - 2.**「对象多态」**：子类对象可以与父类对象进行转换，而且根据其使用的子类不同完成的功能也不同（重写父类的方法）。
    - 多态是同一个行为具有多个不同表现形式或形态的能力。Java语言中含有方法重载与对象多态两种形式的多态：

**「优点」**

1. 1. **「消除类型之间的耦合关系」**
   2. **「可替换性」**
   3. **「可扩充性」**
   4. **「接口性」**
   5. **「灵活性」**
   6. **「简化性」**





#### **2.java 有哪些数据类型？**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-33c267ef58070cbe6a473cbeeabe0d5b_1440w.jpg)

java 主要有两种数据类型

- 1.**「基本数据类型」**

- - byte,short,int,long属于数值型中的整数型
  - float,double属于数值型中的浮点型
  - char属于字符型
  - boolean属于布尔型
  - 基本数据有**「八个」**,

- 2.**「引用数据类型」**

- - 引用数据类型有**「三个」**,分别是类,接口和数组

#### **3.接口和抽象类有什么区别？**

- 1.接口是抽象类的变体，**「接口中所有的方法都是抽象的」**。而抽象类是声明方法的存在而不去实现它的类。
- 2.接口可以多继承，抽象类不行。
- 3.接口定义方法，不能实现，默认是 **「public abstract」**，而抽象类可以实现部分方法。
- 4.接口中基本数据类型为 **「public static final」** 并且需要给出初始值，而抽类象不是的。

#### **4.重载和重写什么区别？**

重写：

- 1.参数列表必须**「完全与被重写的方法」**相同，否则不能称其为重写而是重载.
- 2.**「返回的类型必须一直与被重写的方法的返回类型相同」**，否则不能称其为重写而是重载。
- 3.访问**「修饰符的限制一定要大于被重写方法的访问修饰符」**
- 4.重写方法一定**「不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常」**。

重载：

- 1.必须具有**「不同的参数列表」**；
- 2.可以有不同的返回类型，只要参数列表不同就可以了；
- 3.可以有**「不同的访问修饰符」**；
- 4.可以抛出**「不同的异常」**；

#### **5.常见的异常有哪些？**

- NullPointerException 空指针异常
- ArrayIndexOutOfBoundsException 索引越界异常
- InputFormatException 输入类型不匹配
- SQLException SQL异常
- IllegalArgumentException 非法参数
- NumberFormatException 类型转换异常 等等....

#### **6.异常要怎么解决？**

Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。

Throwable又派生出**「Error类和Exception类」**。

错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。

异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。

处理方法:

- 1.**「try()catch(){}」**

```text
try{
// 程序代码
}catch(ExceptionName e1){
//Catch 块
}
```

- 2.**「throw」**

- - throw 关键字作用是抛出一个异常，抛出的时候是抛出的是一个异常类的实例化对象，在异常处理中，try 语句要捕获的是一个异常对象，那么此异常对象也可以自己抛出

- 3.**「throws」**

- - 定义一个方法的时候可以使用 throws 关键字声明。使用 throws 关键字声明的方法表示此方法不处理异常，而交给方法调用处进行处理。

#### **7.arrayList 和 linkedList 的区别？**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-2d0ab2f17bf59344d3b04a610c7f5fb5_1440w.jpg)

- 1.ArrayList 是实现了基于**「数组」**的，存储空间是连续的。LinkedList 基于**「链表」**的，存储空间是不连续的。（LinkedList 是双向链表）
- 2.对于**「随机访问」** get 和 set ，ArrayList 觉得优于 LinkedList，因为 LinkedList 要移动指针。
- 3.对于**「新增和删除」**操作 add 和 remove ，LinedList 比较占优势，因为 ArrayList 要移动数据。
- 4.同样的数据量 LinkedList 所占用空间可能会更小，因为 ArrayList 需要**「预留空间」**便于后续数据增加，而 LinkedList 增加数据只需要**「增加一个节点」**

#### **8.hashMap 1.7 和 hashMap 1.8 的区别？**

只记录**「重点」**

| 不同点 | hashMap 1.7 | hashMap 1.8 |
| ------ | ----------- | ----------- |
|        |             |             |

#### **9.hashMap 线程不安全体现在哪里？**

在 **「hashMap1.7 中扩容」**的时候，因为采用的是头插法，所以会可能会有循环链表产生，导致数据有问题，在 1.8 版本已修复，改为了尾插法

在任意版本的 hashMap 中，如果在**「插入数据时多个线程命中了同一个槽」**，可能会有数据覆盖的情况发生，导致线程不安全。

#### **10.那么 hashMap 线程不安全怎么解决？**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-22a63c6ee26f6be0b9e7c76ea8e1f09f_1440w.jpg)

- 一.给 hashMap **「直接加锁」**,来保证线程安全
- 二.使用 **「hashTable」**,比方法一效率高,其实就是在其方法上加了 synchronized 锁
- 三.使用 **「concurrentHashMap」** , 不管是其 1.7 还是 1.8 版本,本质都是**「减小了锁的粒度,减少线程竞争」**来保证高效.

#### **11.concurrentHashMap 1.7 和 1.8 有什么区别**

只记录**「重点」**

| 不同点 | concurrentHashMap 1.7 | concurrentHashMap 1.8 |
| ------ | --------------------- | --------------------- |
|        |                       |                       |

#### **12.介绍一下 hashset 吧**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-30bd97a30dd8ce067a3f63a8aa95095c_1440w.jpg)

上图是 set 家族整体的结构，

set 继承于 Collection 接口，是一个**「不允许出现重复元素，并且无序的集合」**.

HashSet 是**「基于 HashMap 实现」**的，底层**「采用 HashMap 来保存元素」**

元素的哈希值是通过元素的 hashcode 方法 来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。

#### **13.什么是泛型？**

泛型:**「把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型」**

#### **14.泛型擦除是什么？**

因为泛型其实只是在编译器中实现的而虚拟机并不认识泛型类项，所以要在虚拟机中将泛型类型进行擦除。也就是说，**「在编译阶段使用泛型，运行阶段取消泛型，即擦除」**。擦除是将泛型类型以其父类代替，如String 变成了Object等。其实在使用的时候还是进行带强制类型的转化，只不过这是比较安全的转换，因为在编译阶段已经确保了数据的一致性。

#### **15.说说进程和线程的区别？**

**「进程是系统资源分配和调度的基本单位」**，它能并发执行较高系统资源的利用率.

**「线程」**是**「比进程更小」**的能独立运行的基本单位,创建、销毁、切换成本要小于进程,可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。

#### **16.volatile 有什么作用？**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-899306b5547c2d4d210a54b63b60634e_1440w.jpg)

- **「1.保证内存可见性」**

- - 可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。

- **「2.禁止指令重排序」**

- - cpu 是和缓存做交互的，但是由于 cpu 运行效率太高，所以会不等待当前命令返回结果从而继续执行下一个命令，就会有乱序执行的情况发生

#### **17.什么是包装类？为什么需要包装类？**

**「Java 中有 8 个基本类型，分别对应的 8 个包装类」**

- byte -- Byte
- boolean -- Boolean
- short -- Short
- char -- Character
- int -- Integer
- long -- Long
- float -- Float
- double -- Double

**「为什么需要包装类」**:

- 基本数据类型方便、简单、高效，但泛型不支持、集合元素不支持
- 不符合面向对象思维
- 包装类提供很多方法，方便使用，如 Integer 类 toHexString(int i)、parseInt(String s) 方法等等

#### **18.Integer a = 1000，Integer b = 1000，a==b 的结果是什么？那如果 a，b 都为1，结果又是什么？**

Integer a = 1000，Integer b = 1000，a==b 结果为**「false」**

Integer a = 1，Integer b = 1，a==b 结果为**「true」**

这道题主要考察 Integer 包装类缓存的范围,**「在-128~127之间会缓存起来」**,比较的是直接缓存的数据,在此之外比较的是对象

#### **19.JMM 是什么？**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-f59ebeba510528ccdf0e22b46358794c_1440w.jpg)

JMM 就是 **「Java内存模型」**(java memory model)。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以java内存模型(JMM)**「屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果」**。

Java内存模型规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。**「线程不能直接读写主内存中的变量」**。

每个线程的工作内存都是独立的，**「线程操作数据只能在工作内存中进行，然后刷回到主存」**。这是 Java 内存模型定义的线程基本工作方式。

#### **20.创建对象有哪些方式**

有**「五种创建对象的方式」**

- 1、new关键字

```text
Person p1 = new Person();
```

- 2.Class.newInstance

```text
Person p1 = Person.class.newInstance();
```

- 3.Constructor.newInstance

```text
Constructor<Person> constructor = Person.class.getConstructor();
Person p1 = constructor.newInstance();
```

- 4.clone

```text
Person p1 = new Person();
Person p2 = p1.clone();
```

- 5.反序列化

```text
Person p1 = new Person();
byte[] bytes = SerializationUtils.serialize(p1);
Person p2 = (Person)SerializationUtils.deserialize(bytes);
```

#### **21.讲讲单例模式懒汉式吧**

直接贴代码

```text
// 懒汉式
public class Singleton {
// 延迟加载保证多线程安全
    Private volatile static Singleton singleton;
    private Singleton(){}
    public static Singleton getInstance(){
        if(singleton == null){
            synchronized(Singleton.class){
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

- 使用 volatile 是**「防止指令重排序，保证对象可见」**，防止读到半初始化状态的对象
- 第一层if(singleton == null) 是为了防止有多个线程同时创建
- synchronized 是加锁防止多个线程同时进入该方法创建对象
- 第二层if(singleton == null) 是防止有多个线程同时等待锁，一个执行完了后面一个又继续执行的情况

#### **22.volatile 有什么作用**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-3cc24e0a9fd853f3c8a1561284b8de47_1440w.jpg)

- 1.**「保证内存可见性」**

- - 当一个被volatile关键字修饰的变量被一个线程修改的时候，其他线程可以立刻得到修改之后的结果。当一个线程向被volatile关键字修饰的变量**「写入数据」**的时候，虚拟机会**「强制它被值刷新到主内存中」**。当一个线程**「读取」**被volatile关键字修饰的值的时候，虚拟机会**「强制要求它从主内存中读取」**。

- 2.**「禁止指令重排序」**

- - 指令重排序是编译器和处理器为了高效对程序进行优化的手段，cpu 是与内存交互的，而 cpu 的效率想比内存高很多，所以 cpu 会在不影响最终结果的情况下，不等待返回结果直接进行后续的指令操作，而 volatile 就是给相应代码加了**「内存屏障」**，在屏障内的代码禁止指令重排序。

#### **23.怎么保证线程安全？**

- 1.synchronized关键字

- - 可以用于代码块，方法（静态方法，同步锁是当前字节码对象；实例方法，同步锁是实例对象）

- 2.lock锁机制

```text
Lock lock = new ReentrantLock();
lock. lock();
try {
    System. out. println("获得锁");
} catch (Exception e) {
   
} finally {
    System. out. println("释放锁");
    lock. unlock();
}
```

#### **24.synchronized 锁升级的过程**

在 Java1.6 之前的版本中，synchronized 属于重量级锁，效率低下，**「锁是」** cpu 一个**「总量级的资源」**，每次获取锁都要和 cpu 申请，非常消耗性能。

在 **「jdk1.6 之后」** Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了，Jdk1.6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁和轻量级锁，**「增加了锁升级的过程」**，由无锁->偏向锁->自旋锁->重量级锁

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-d452593e203c25f0cae0925e1e293f17_1440w.jpg)



增加锁升级的过程主要是**「减少用户态到核心态的切换，提高锁的效率，从 jvm 层面优化锁」**

#### **25.cas 是什么？**

cas 叫做 CompareAndSwap，**「比较并交换」**，很多地方使用到了它，比如锁升级中自旋锁就有用到，主要是**「通过处理器的指令来保证操作的原子性」**，它主要包含三个变量：

- **「1.变量内存地址」**
- **「2.旧的预期值 A」**
- **「3.准备设置的新值 B」**

当一个线程需要修改一个共享变量的值，完成这个操作需要先取出共享变量的值，赋给 A，基于 A 进行计算，得到新值 B，在用预期原值 A 和内存中的共享变量值进行比较，**「如果相同就认为其他线程没有进行修改」**，而将新值写入内存

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-a4cc706cf50071e036d71050f6a1abd5_1440w.jpg)

**「CAS的缺点」**

- **「CPU开销比较大」**：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，又因为自旋的时候会一直占用CPU，如果CAS一直更新不成功就会一直占用，造成CPU的浪费。
- **「ABA 问题」**：比如线程 A 去修改 1 这个值，修改成功了，但是中间 线程 B 也修改了这个值，但是修改后的结果还是 1，所以不影响 A 的操作，这就会有问题。可以用**「版本号」**来解决这个问题。
- **「只能保证一个共享变量的原子性」**

#### **26.聊聊 ReentrantLock 吧**

ReentrantLock 意为**「可重入锁」**，说起 ReentrantLock 就不得不说 AQS ，因为其底层就是**「使用 AQS 去实现」**的。

ReentrantLock有两种模式，一种是公平锁，一种是非公平锁。

- 公平模式下等待线程入队列后会严格按照队列顺序去执行
- 非公平模式下等待线程入队列后有可能会出现插队情况

**「公平锁」**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-729666c6a03fef652c8cb12719b8ad5d_1440w.jpg)

- 第一步：**「获取状态的 state 的值」**

- - 如果 state=0 即代表锁没有被其它线程占用，执行第二步。
  - 如果 state!=0 则代表锁正在被其它线程占用，执行第三步。

- 第二步：**「判断队列中是否有线程在排队等待」**

- - 如果不存在则直接将锁的所有者设置成当前线程，且更新状态 state 。
  - 如果存在就入队。

- 第三步：**「判断锁的所有者是不是当前线程」**

- - 如果是则更新状态 state 的值。
  - 如果不是，线程进入队列排队等待。

**「非公平锁」**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-620022456c5f48c1cc43dcfd7fce2dac_1440w.jpg)

- 获取状态的 state 的值

- - 如果 state=0 即代表锁没有被其它线程占用，则设置当前锁的持有者为当前线程，该操作用 CAS 完成。
  - 如果不为0或者设置失败，代表锁被占用进行下一步。

- 此时**「获取 state 的值」**

- - 如果是，则给state+1，获取锁
  - 如果不是，则进入队列等待
  - 如果是0，代表刚好线程释放了锁，此时将锁的持有者设为自己
  - 如果不是0，则查看线程持有者是不是自己

#### **27.多线程的创建方式有哪些？**

- 1、**「继承Thread类」**，重写run()方法

```text
public class Demo extends Thread{
    //重写父类Thread的run()
    public void run() {
    }
    public static void main(String[] args) {
        Demo d1 = new Demo();
        Demo d2 = new Demo();
        d1.start();
        d2.start();
    }
}
```

- 2.**「实现Runnable接口」**，重写run()

```text
public class Demo2 implements Runnable{

    //重写Runnable接口的run()
    public void run() {
    }
    
    public static void main(String[] args) {
        Thread t1 = new Thread(new Demo2());
        Thread t2 = new Thread(new Demo2());
        t1.start();
        t2.start();
    }

}
```

- 3.**「实现 Callable 接口」**

```text
public class Demo implements Callable<String>{

    public String call() throws Exception {
        System.out.println("正在执行新建线程任务");
        Thread.sleep(2000);
        return "结果";
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        Demo d = new Demo();
        FutureTask<String> task = new FutureTask<>(d);
        Thread t = new Thread(task);
        t.start();
        //获取任务执行后返回的结果
        String result = task.get();
    }
    
}
```

- 4.**「使用线程池创建」**

```text
public class Demo {
    public static void main(String[] args) {
        Executor threadPool = Executors.newFixedThreadPool(5);
        for(int i = 0 ;i < 10 ; i++) {
            threadPool.execute(new Runnable() {
                public void run() {
                    //todo
                }
            });
        }
        
    }
}
```

#### **28.线程池有哪些参数？**

- **「1.corePoolSize」**：**「核心线程数」**，线程池中始终存活的线程数。
- **「2.maximumPoolSize」**: **「最大线程数」**，线程池中允许的最大线程数。
- **「3.keepAliveTime」**: **「存活时间」**，线程没有任务执行时最多保持多久时间会终止。
- **「4.unit」**: **「单位」**，参数keepAliveTime的时间单位，7种可选。
- **「5.workQueue」**: 一个**「阻塞队列」**，用来存储等待执行的任务，均为线程安全，7种可选。
- **「6.threadFactory」**: **「线程工厂」**，主要用来创建线程，默及正常优先级、非守护线程。
- **「7.handler」**：**「拒绝策略」**，拒绝处理任务时的策略，4种可选，默认为AbortPolicy。

#### **29.线程池的执行流程？**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-edc42e2023649ee1fe440af962fe2214_1440w.jpg)

- 判断线程池中的线程数**「是否大于设置的核心线程数」**

- - 如果**「没有满」**，则**「放入队列」**，等待线程空闲时执行任务
  - 如果队列已经**「满了」**，则判断**「是否达到了线程池设置的最大线程数」**
  - 如果**「没有达到」**，就**「创建新线程」**来执行任务
  - 如果已经**「达到了」**最大线程数，则**「执行指定的拒绝策略」**
  - 如果**「小于」**，就**「创建」**一个核心线程来执行任务
  - 如果**「大于」**，就会**「判断缓冲队列是否满了」**

#### **30.线程池的拒绝策略有哪些？**

- **「AbortPolicy」**：直接丢弃任务，抛出异常，这是默认策略
- **「CallerRunsPolicy」**：只用调用者所在的线程来处理任务
- **「DiscardOldestPolicy」**：丢弃等待队列中最旧的任务，并执行当前任务
- **「DiscardPolicy」**：直接丢弃任务，也不抛出异常

#### **31.介绍一下四种引用类型?**

- **「强引用 StrongReference」**

```text
Object obj = new Object(); 
//只要obj还指向Object对象，Object对象就不会被回收
```

垃圾回收器不会回收被引用的对象，哪怕内存不足时，JVM 也会直接抛出 OutOfMemoryError，除非赋值为 null。

- **「软引用 SoftReference」**

软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。

- **「弱引用 WeakReference」**

弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。

- **「虚引用 PhantomReference」**

虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用，NIO 的堆外内存就是靠其管理。

#### **32.深拷贝、浅拷贝是什么？**

- 浅拷贝并不是真的拷贝，只是**「复制指向某个对象的指针」**，而不复制对象本身，新旧对象还是共享同一块内存。
- 深拷贝会另外**「创造一个一模一样的对象」**，新对象跟原对象不共享内存，修改新对象不会改到原对象。

#### **33.聊聊 ThreadLocal 吧**

- ThreadLocal其实就是**「线程本地变量」**，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离。

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-df508a1d440362de2eabb540312a537d_1440w.jpg)



- ThreadLocal 有一个**「静态内部类 ThreadLocalMap」**，ThreadLocalMap 又包含了一个 Entry 数组，**「Entry 本身是一个弱引用」**，他的 key 是指向 ThreadLocal 的弱引用，**「弱引用的目的是为了防止内存泄露」**,如果是强引用那么除非线程结束,否则无法终止,可能会有内存泄漏的风险。
- 但是这样还是会存在内存泄露的问题，假如 key 和 ThreadLocal 对象被回收之后，entry 中就存在 key 为 null ，但是 value 有值的 entry 对象，但是永远没办法被访问到，同样除非线程结束运行。**「解决方法就是调用 remove 方法删除 entry 对象」**。

#### **34.一个对象的内存布局是怎么样的?**

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/v2-29b059c703d61b2472be4a4cacb6edfe_1440w.jpg)

- **「1.对象头」**: 对象头又分为 **「MarkWord」** 和 **「Class Pointer」** 两部分。

- - **「MarkWord」**:包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位,gc记录信息等等。
  - **「ClassPointer」**:用来指向对象对应的 Class 对象（其对应的元数据对象）的内存地址。在 32 位系统占 4 字节，在 64 位系统中占 8 字节。

- **「2.Length」**:只在数组对象中存在，用来记录数组的长度，占用 4 字节

- **「3.Instance data」**: 对象实际数据，对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定。(这里不包括静态成员变量，因为其是在方法区维护的)

- **「4.Padding」**:Java 对象占用空间是 8 字节对齐的，即所有 Java 对象占用 bytes 数必须是 8 的倍数,是因为当我们从磁盘中取一个数据时，不会说我想取一个字节就是一个字节，都是按照一块儿一块儿来取的，这一块大小是 8 个字节，所以为了完整，padding 的作用就是补充字节，**「保证对象是 8 字节的整数倍」**。







### 数据库

#### 1、谈一谈数据库中主键约束和唯一约束的区别和联系？？

|          | 能否保证唯一性 | 是否允许为空 | 一个表中可以有多少列使用 | 是否允许组合     |
| -------- | -------------- | ------------ | ------------------------ | ---------------- |
| 主键约束 | 能             | 不允许       | 至多有一列               | 允许，但是不推荐 |
| 唯一约束 | 能             | 允许         | 可以有多列               | 允许，但是不推荐 |



#### 2、谈谈数据库外键的使用及优缺点？？？？

外键：

- 要求在从表中设置外键关系
- 从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求
- 主表的关联列必须是一个key（一般是主键约束或唯一约束）
- 插入数据时，必须先插入主表，再插入从表【因为从表引用主表数据】
- 删除数据时，必须先删除从表，再删除主表【同上】

#### 3、事务的特性（ACID属性） <font color='red'>**【高频考点】**</font>

-  <font color='red'>**原子性（Atomicity）**</font>
   - 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
-  <font color='red'>**一致性（Consistency）**</font>
   - 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。
-  <font color='red'>**隔离性（Isolation）**</font>
   - 事务的隔离性是指一个事务的执行不能被其他事物干扰，即一个事务的内部操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。
-  <font color='red'>**持久性（Durability）**</font>
   - 持久性是指一个事务一旦被提交他对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何的影响。

#### 4、据库的隔离级别

- 对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题：

  - <font color='red'>脏读</font>：对于两个事务甲、乙，当甲读取了已经被乙更新但还<font color='blue'>没有提交</font>的字段，之后若乙发生了回滚，甲读取的内容就是临时的，且无效的。
  - <font color='red'>不可重复读</font>：对于两个事务甲、乙，甲读取了一个字段，然后乙<font color='blue'>更新</font>了该字段，之后甲再次读取同一个字段时，字段的值就不同了。
  - <font color='red'>幻读</font>：对于两个事务甲、乙，甲从表中读取了一个字段，然后乙在该表中<font color='blue'>插入</font>了一些新的行，如果甲再次读取同一个表，就会多出几行。

- **数据库事务的隔离性：**数据库系统必须具有隔离并发运行各个事务的能力，使他们不会互相影响，避免各种并发问题

- 一个事务与其他事务隔离的程度称为隔离级别，数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，<font color='blue'>**隔离级别越高，数据的一致性就越好，但并发性越弱**</font>。

- 数据库提供了4种隔离级别：

- | 隔离强度 | 支持         | 隔离级别                             | 描述                                                         |
  | -------- | ------------ | ------------------------------------ | ------------------------------------------------------------ |
  | 最低     | MySQL        | READ UNCOMMITTED<br />(读未提交数据) | 允许事务读取未被其他事物提交的表更、脏读、不可重复读和幻读的问题都会出现 |
  |          | Oracle/MySQL | READ COMMITED<BR />(读已提交数据)    | 只允许事务读取已经被其他事物提交的变更、可以避免脏读、但但但不可重复读和幻读问题仍可能会出现 |
  |          | MySQL        | REPEATABLE READ<br/>(可重复读)       | 确保事务可以多次从一个字段中读取相同的值，但这个事务持续期间，禁止其他事物对这个字段进行更新，可以避免脏读和不可重复读，但但但幻读问题仍然存在 |
  | 最高     | Oracle/MySQL | SERIALIZABLE(串行化)                 | 确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，所有并发问题都可以避免，但性能十分低下 |

  |                  | 脏读     | 不可重复读 | 幻读     |
  | ---------------- | -------- | ---------- | -------- |
  | read uncommitted | 会出现   | 会出现     | 会出现   |
  | read committed   | 不会出现 | 会出现     | 会出现   |
  | repeatable read  | 不会出现 | 不会出现   | 会出现   |
  | serializable     | 不会出现 | 不会出现   | 不会出现 |

- <font color='red'>MySQL</font>中默认是 第三个隔离级别 <font color='red'>repeatable read</font>

- <font color='red'>Oracle</font>中默认是 第二个隔离级别 <font color='red'>read committed</font>





#### 5、试问：下面两段代码输出结果一样吗？

> ```sql
> -- 代码一
> SELECT
> 	*
> FROM
> 	city;
> ```
>
> ```sql
> -- 代码二
> SELECT
> 	* 
> FROM
> 	city
> WHERE
> 	id LIKE '%%' AND Population LIKE '%%';
> ```
>
> 

**答：不一定相同；**

> 代码一：输出city表中所有的字段
>
> 代码二：对city表中的两个字段进行了模糊搜索，通配符%%全部匹配，正常来说，应该返回的也是所有数据，<font color='red'>但是：如果其中一个字段中包含null，那么就不能匹配，导致数据丢失</font>
>
> <font color='red'>若把AND 改成 OR，并把所有字段名全写上</font>，则会输出所有数据，除非有一行数据全部为null，因为使用OR 只要有一个不是null，就不影响数据输出

#### 为什么要使用数据库？

- 数据保存在内存

  - 优点：存取速度快

  - 缺点：数据不能永久保存


- 数据保存在文件

  - 优点：数据永久保存

  - 缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便


- 数据保存在数据库

  - 1）数据永久保存

  - 2）使用SQL语句，查询方便效率高。


  - 3）管理数据方便

#### 什么是SQL？

结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。

作用：用于存取数据、查询、更新和管理关系数据库系统。

#### 什么是MySQL?

MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。

#### 数据库三大范式是什么

第一范式：每个列都不可以再拆分。

第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。

第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。

在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。

#### mysql有关权限的表都有哪几个

MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：

user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
db权限表：记录各个帐号在各个数据库上的操作权限。
table_priv权限表：记录数据表级的操作权限。
columns_priv权限表：记录数据列级的操作权限。
host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。
#### MySQL的binlog有有几种录入格式？分别有什么区别？

有三种格式，statement，row和mixed。

statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。



#### mysql有哪些数据类型

1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。
长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。
例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。
2、实数类型，包括FLOAT、DOUBLE、DECIMAL。
DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。
而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。
计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。
3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB
VARCHAR用于存储可变长字符串，它比定长类型更节省空间。
VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。
VARCHAR存储的内容超出设置的长度时，内容会被截断。
CHAR是定长的，根据定义的字符串长度分配足够的空间。
CHAR会根据需要使用空格进行填充方便比较。
CHAR适合存储很短的字符串，或者所有值都接近同一个长度。
CHAR存储的内容超出设置的长度时，内容同样会被截断。
使用策略：
对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。
对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。
使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。
尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。
4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。
有时可以使用ENUM代替常用的字符串类型。
ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。
ENUM在内部存储时，其实存的是整数。
尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。
排序是按照内部存储的整数
5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，
用整数保存时间戳通常不方便处理。
如果需要存储微妙，可以使用bigint存储。
看到这里，这道真题是不是就比较容易回答了。



#### MySQL存储引擎MyISAM与InnoDB区别？

存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。

常用的存储引擎有以下：

- Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
- MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。
- MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。

#### MyISAM索引与InnoDB索引的区别？

InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。
#### InnoDB引擎的4大特性

- 插入缓冲（insert buffer)
- 二次写(double write)
- 自适应哈希索引(ahi)
- 预读(read ahead)

存储引擎选择
如果没有特别的需求，使用默认的Innodb即可。

MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。

Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。

#### 什么是索引？

索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。

#### 索引有哪些优缺点？

索引的优点

- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

索引的缺点

- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；
- 空间方面：索引需要占物理空间。

索引使用场景（重点）
where

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png.jpeg)

上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。

```mysql
-- 增加一个没有建立索引的字段
alter table innodb1 add sex char(1);
-- 按sex检索时可选的索引为null
EXPLAIN SELECT * from innodb1 where sex='男';
```

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png.png)

可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显)。
order by

当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。

但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）

join

对join语句匹配关系（on）涉及的字段建立索引能够提高效率
索引覆盖

如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。

这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。

4. 索引有哪几种类型？
主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。

唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。

可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引
可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引
普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。

可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引
可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引
全文索引：是目前搜索引擎使用的一种关键技术。

可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引
5. 索引的数据结构（b树，hash）
索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

1）B树索引

mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219112607037.jpeg)

查询方式：

主键索引区:PI(关联保存的时数据的地址)按主键查询,

普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快

B+tree性质：

1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。

2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。

4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。

5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。

2）哈希索引

简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。

 ![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219112615990.png)

 

#### 索引的基本原理

索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。

索引的原理很简单，就是把无序的数据变成有序的查询

把创建了索引的列的内容进行排序
对排序结果生成倒排表
在倒排表内容上拼上数据地址链
在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据
#### 索引算法有哪些？

索引算法有 BTree算法和Hash算法

BTree算法

BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：

```mysql
-- 只要它的查询条件是一个不以通配符开头的常量
select * from user where name like 'jack%';
-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如：
select * from user where name like '%jack';Hash算法
```

Hash Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。

8. 索引设计的原则？
适合索引的列是出现在where子句中的列，或者连接子句中指定的列
基数较小的类，索引效果较差，没有必要在此列建立索引
使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间
不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
9. 创建索引的原则（重中之重）
索引虽好，但也不是无限制的使用，最好符合一下几个原则

1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2）较频繁作为查询条件的字段才去创建索引

3）更新频繁字段不适合创建索引

4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)

5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

6）定义有外键的数据列一定要建立索引。

7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。

8）对于定义为text、image和bit的数据类型的列不要建立索引。

10. 创建索引的三种方式，删除索引
第一种方式：在执行CREATE TABLE时创建索引

```mysql
CREATE TABLE user_index2 (
	id INT auto_increment PRIMARY KEY,
	first_name VARCHAR (16),
	last_name VARCHAR (16),
	id_card VARCHAR (18),
	information text,
	KEY name (first_name, last_name),
	FULLTEXT KEY (information),
	UNIQUE KEY (id_card)
);
```


第二种方式：使用ALTER TABLE命令去增加索引

```mysql
ALTER TABLE table_name ADD INDEX index_name (column_list);
```


ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。

其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。

索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。

第三种方式：使用CREATE INDEX命令创建

```mysql
CREATE INDEX index_name ON table_name (column_list);
CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）
```

删除索引

根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名

```mysql
alter table user_index drop KEY name;
alter table user_index drop KEY id_card;
alter table user_index drop KEY information;
```


删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：



需要取消自增长再行删除：

```mysql
alter table user_index
-- 重新定义字段
MODIFY id int,
drop PRIMARY KEY
```


但通常不会删除主键，因为设计主键一定与业务逻辑无关。

#### 创建索引时需要注意什么？

非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；
取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；

索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。

#### 使用索引查询一定能提高查询的性能吗？为什么

通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。

索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:
基于一个范围的检索，一般查询返回结果集小于表中记录数的30%
基于非唯一性索引的检索
#### 百万级别或以上的数据如何删除

关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。

所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）
然后删除其中无用数据（此过程需要不到两分钟）
删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。
与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。
#### 前缀索引

语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。

前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。

实操的难度：在于前缀截取的长度。

我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）

#### 什么是最左前缀原则？什么是最左匹配原则

顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

#### B树和B+树的区别

在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。
B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。

#### 使用B树的好处

- B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。

- 由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间

#### Hash索引和B+树所有有什么区别或者说优劣呢?

首先要知道Hash索引和B+树索引的底层实现原理：

hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。

那么可以看出他们有以下的不同：

hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。
因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。

hash索引不支持使用索引进行排序，原理同上。
hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。
hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。
因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。

#### 数据库为什么使用B+树而不是B树

B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；
B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。
增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。

#### B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据

在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。

当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。

#### 什么是聚簇索引？何时使用聚簇索引与非聚簇索引

聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因
澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值

何时使用聚簇索引与非聚簇索引

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219113149456.png)

#### 非聚簇索引一定会回表查询吗？

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。

举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。

#### 联合索引是什么？为什么需要注意联合索引中的顺序？

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

#### 什么是数据库事务？

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

事务最经典也经常被拿出来说例子就是转账了。

假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。



#### 对MySQL的锁了解吗

当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。

就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。

#### 隔离级别与锁的关系

在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突

在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；

在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

#### 按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法

在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。

MyISAM和InnoDB存储引擎使用的锁：

MyISAM采用表级锁(table-level locking)。
InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁
行级锁，表级锁和页级锁对比

行级锁 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。

特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

#### 从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了

从锁的类别上来讲，有共享锁和排他锁。

共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。

排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。

用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。

锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。

他们的加锁开销从大到小，并发能力也是从大到小。

#### MySQL中InnoDB引擎的行锁是怎么实现的？

答：InnoDB是基于索引来完成行锁

例: select * from tab_with_index where id = 1 for update;

for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起

#### InnoDB存储引擎的锁的算法有三种

Record lock：单个行记录上的锁
Gap lock：间隙锁，锁定一个范围，不包括记录本身
Next-key lock：record+gap 锁定一个范围，包含记录本身
相关知识点：

innodb对于行的查询使用next-key lock
Next-locking keying为了解决Phantom Problem幻读问题
当查询的索引含有唯一属性时，将next-key lock降级为record key
Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1
#### 什么是死锁？怎么解决？

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法

1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。

2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用分布式事务锁或者使用乐观锁

#### 数据库的乐观锁和悲观锁是什么？怎么实现的？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

==悲观锁：==假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制

==乐观锁：==假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。

两种锁的使用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

#### 为什么要使用视图？什么是视图？

为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。

视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。

#### 视图有哪些特点？

视图的特点如下:

视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。
视图是由基本表(实表)产生的表(虚表)。
视图的建立和删除不影响基本表。
对视图内容的更新(添加，删除和修改)直接影响基本表。
当视图来自多个基本表时，不允许添加和删除数据。
视图的操作包括创建视图，查看视图，删除视图和修改视图。

#### 视图的使用场景有哪些？

视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。

下面是视图的常见使用场景：

重用SQL语句；
简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；
使用表的组成部分而不是整个表；
保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；
更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。
#### 视图的优点

查询简单化。视图能简化用户的操作
数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护
逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性

#### 视图的缺点

性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。
修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的
这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）

#### 什么是游标？

游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。

存储过程与函数
什么是存储过程？有哪些优缺点？
存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。

优点

1）存储过程是预编译过的，执行效率高。

2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。

3）安全性高，执行存储过程需要有一定权限的用户。

4）存储过程可以重复使用，减少数据库开发人员的工作量。

缺点

1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。

2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。

3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。

4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。

触发器
#### 什么是触发器？触发器的使用场景有哪些？

触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。

使用场景

可以通过数据库中的相关表实现级联更改。
实时监控某张表中的某个字段的更改而需要做出相应的处理。
例如可以生成某些业务的编号。
注意不要滥用，否则会造成数据库及应用程序的维护困难。
大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。
#### MySQL中都有哪些触发器？

在MySQL数据库中有如下六种触发器：

Before Insert
After Insert
Before Update
After Update
Before Delete
After Delete
常用SQL语句
#### SQL语句主要分为哪几类

数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER

主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。

数据查询语言DQL（Data Query Language）SELECT

这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。

数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE

主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。

数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK

主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。

#### 超键、候选键、主键、外键分别是什么？

超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
候选键：是最小超键，即没有冗余元素的超键。
主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
外键：在一个表中存在的另一个表的主键称此表的外键。

#### SQL 约束有哪几种？

SQL 约束有哪几种？
NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
CHECK: 用于控制字段的值范围。

#### 六种关联查询

- 交叉连接（CROSS JOIN）
- 内连接（INNER JOIN）
- 外连接（LEFT JOIN/RIGHT JOIN）
- 联合查询（UNION与UNION ALL）
- 全连接（FULL JOIN）
- 交叉连接（CROSS JOIN）

SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN
内连接分为三类

等值连接：ON A.id=B.id
不等值连接：ON A.id > B.id
自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid
外连接（LEFT JOIN/RIGHT JOIN）

左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN
右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN
联合查询（UNION与UNION ALL）

SELECT * FROM A UNION SELECT * FROM B UNION ...
就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并
如果使用UNION ALL，不会合并重复的记录行
效率 UNION 高于 UNION ALL
全连接（FULL JOIN）

MySQL不支持全连接
可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用
```SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id```
表连接面试题

有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。

R表

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219113624137.png)

S表

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219113629976.png)

交叉连接(笛卡尔积):
select r.*,s.* from r,s

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219113634994.jpeg)

内连接结果：
select r.*,s.* from r inner join s on r.c=s.c

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219113646735.png)

左连接结果：
select r.*,s.* from r left join s on r.c=s.c

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219113652524.png)

右连接结果：
select r.*,s.* from r right join s on r.c=s.c

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219113659509.png)

全表连接的结果（MySql不支持，Oracle支持）：
select r.*,s.* from r full join s on r.c=s.c

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219113704743.png)

#### 什么是子查询

条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果
嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。

#### 子查询的三种情况

子查询是单行单列的情况：结果集是一个值，父查询使用：=、 <、 > 等运算符

```mysql 
-- 查询工资最高的员工是谁？
select  * from employee where salary=(select max(salary) from employee);
```


子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符

```mysql
-- 查询工资最高的员工是谁？
select  * from employee where salary=(select max(salary) from employee);
```

子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表

```mysql
-- 1) 查询出2011年以后入职的员工信息
-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。
select * from dept d,  (select * from employee where join_date > '2011-1-1') e where e.dept_id =  d.id;

– 使用表连接：

select d., e. from  dept d inner join employee e on d.id = e.dept_id where e.join_date >  ‘2011-1-1’
```


#### mysql中 in 和 exists 区别

mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。

如果查询的两个表大小相当，那么用in和exists差别不大。
如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。
not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。
#### varchar与char的区别

- char的特点

char表示定长字符串，长度是固定的；
如果插入数据的长度小于char的固定长度时，则用空格填充；
因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；
对于char来说，最多能存放的字符个数为255，和编码无关

- varchar的特点

varchar表示可变长字符串，长度是可变的；
插入的数据是多长，就按照多长来存储；
varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；
对于varchar来说，最多能存放的字符个数为65532
总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。

#### varchar(50)中50的涵义

最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。

#### int(20)中20的涵义

是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；

不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示

mysql为什么这么设计
对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；

#### mysql中int(10)和char(10)以及varchar(10)的区别

int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。
int(10) 10位的数据长度 9999999999，占32个字节，int型4位
char(10) 10位固定字符串，不足补空格 最多10个字符
varchar(10) 10位可变字符串，不足补空格 最多10个字符
char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间
varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符

#### FLOAT和DOUBLE的区别是什么？

FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。
DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。

#### drop、delete与truncate的区别

三者都表示删除，但是三者有一些差别：

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219114026457.png)

因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。

#### UNION与UNION ALL的区别？

如果使用UNION ALL，不会合并重复的记录行
效率 UNION 高于 UNION ALL
SQL优化

#### 如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？

对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219114105073.png)

执行计划包含的信息 id 有一组数字组成。表示一个查询中各个子查询的执行顺序;

- id相同执行顺序由上至下。

- id不同，id值越大优先级越高，越先被执行。
- id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。

select_type 每个子查询的查询类型，一些常见的查询类型。

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219114122554.jpeg)

table 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id partitions 表分区、表创建的时候可以指定通过那个列进行表分区。举个例子：

```mysql
create table tmp (
    id int unsigned not null AUTO_INCREMENT,
    name varchar(255),
    PRIMARY KEY (id)
) engine = innodb
partition by key (id) partitions 5;
```


type(非常重要，可以看到有没有走索引) 访问类型

- ALL 扫描全表数据

- index 遍历索引
- range 索引范围查找
- index_subquery 在子查询中使用 ref
- unique_subquery 在子查询中使用 eq_ref
- ref_or_null 对Null进行索引的优化的 ref
- fulltext 使用全文索引
- ref 使用非唯一索引查找数据
- eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。

possible_keys 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。

key 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。

TIPS:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中

key_length 索引长度

ref 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

rows 返回估算的结果集数目，并不是一个准确的值。

extra 的信息非常丰富，常见的有：

- Using index 使用覆盖索引
- Using where 使用了用where子句来过滤结果集
- Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。
- Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册

【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。
说明：
1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
2） ref 指的是使用普通的索引（normal index）。
3） range 对索引进行范围检索。
反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。

#### SQL的生命周期？

应用服务器与数据库服务器建立一个连接
数据库进程拿到请求sql
解析并生成执行计划，执行
读取数据到内存并进行逻辑处理
通过步骤一的连接，发送结果到客户端
关掉连接，释放资源

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219114314695.jpeg)

#### 大表数据查询，怎么优化

优化shema、sql语句+索引；
第二加缓存，memcached, redis；
主从复制，读写分离；
垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；
水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；

#### 超大分页怎么处理？

超大的分页一般从两个方向上来解决.

数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age > 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age > 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id > 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.
从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.
解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.

在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.

【推荐】利用延迟关联或者子查询优化超多分页场景。

说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。

正例：先快速定位需要获取的id段，然后再关联：

```mysql
SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id
```

#### mysql 分页

LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)

mysql> SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15
为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：

mysql> SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.
如果只给定一个参数，它表示返回最大的记录行数目：

mysql> SELECT * FROM table LIMIT 5; //检索前 5 个记录行
换句话说，LIMIT n 等价于 LIMIT 0,n。

#### 慢查询日志

用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。
开启慢查询日志

配置项：slow_query_log

可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。

设置临界时间

配置项：long_query_time

查看：show VARIABLES like 'long_query_time'，单位秒

设置：set long_query_time=0.5

实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉

查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中

#### 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？

在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。

#### 慢查询的优化首先要搞明白慢的原因是什么？是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？

所以优化也是针对这三个方向来的，

首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。
分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。
如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。
#### 为什么要尽量设定一个主键？

主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。

#### 主键使用自增ID还是UUID？

推荐使用自增ID，不要使用UUID。

因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。

总之，在数据量大一些的情况下，用自增主键性能会好一些。

关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。

#### 字段为什么要求定义为not null？

null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。

#### 如果要存储用户的密码散列，应该使用什么字段进行存储？

密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。

#### 优化查询过程中的数据访问

访问数据太多导致查询性能下降
确定应用程序是否在检索大量超过需要的数据，可能是太多行或列
确认MySQL服务器是否在分析大量不必要的数据行
避免犯如下SQL语句错误
查询不需要的数据。解决办法：使用limit解决
多表关联返回全部列。解决办法：指定列名
总是返回全部列。解决办法：避免使用SELECT *
重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存
是否在扫描额外的记录。解决办法：
使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：
使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
改变数据库和表的结构，修改数据表范式
重写SQL语句，让优化器可以以更优的方式执行查询。

#### 优化长难的查询语句

一个复杂查询还是多个简单查询
MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多
使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。
切分查询
将一个大的查询分为多个小的相同的查询
一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。
分解关联查询，让缓存的效率更高。
执行单个查询可以减少锁的竞争。
在应用层做关联更容易对数据库进行拆分。
查询效率会有大幅提升。
较少冗余记录的查询。

#### 优化特定类型的查询语句

count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)
MyISAM中，没有任何where条件的count(*)非常快。
当有where条件时，MyISAM的count统计不一定比其它引擎快。
可以使用explain查询近似值，用近似值替代count(*)
增加汇总表
使用缓存

#### 优化关联查询

确定ON或者USING子句中是否有索引。
确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。

#### 优化子查询

用关联查询替代
优化GROUP BY和DISTINCT
这两种查询据可以使用索引来优化，是最有效的优化方法
关联查询中，使用标识列分组的效率更高
如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。
WITH ROLLUP超级聚合，可以挪到应用程序处理

#### 优化LIMIT分页

LIMIT偏移量大的时候，查询效率较低
可以记录上次查询的最大ID，下次查询时直接根据该ID来查询

#### 优化UNION查询

UNION ALL的效率高于UNION

#### 优化WHERE子句

解题方法

对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。

SQL语句优化的一些方法？

1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：

```mysql
select id from t where num is null
-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
select id from t where num=0
```

3.应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。
4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：

```mysql
select id from t where num=10 or num=20
-- 可以这样查询：
select id from t where num=10 union all select id from t where num=20
```


http://5.in 和 not in 也要慎用，否则会导致全表扫描，如：

```mysql
select id from t where num in(1,2,3)
-- 对于连续的数值，能用 between 就不要用 in 了：
select id from t where num between 1 and 3
```

6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。
7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：

```mysql
select id from t where num=@num
-- 可以改为强制查询使用索引：
select id from t with(index(索引名)) where num=@num
```

8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：

```mysql
select id from t where num/2=100
-- 应改为:
select id from t where num=100*2
```

9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：

```mysql
select id from t where substring(name,1,3)=’abc’
-- name以abc开头的id应改为:
select id from t where name like ‘abc%’
```


10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

#### 数据库为什么要优化？

系统的吞吐量瓶颈往往出现在数据库的访问速度上
随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢
数据是存放在磁盘上的，读写速度无法和内存相比
优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。

#### 数据库结构优化

一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。

需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。

将字段很多的表分解成多个表

对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。

因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。

增加中间表

对于需要经常联合查询的表，可以建立中间表以提高查询效率。

通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。

增加冗余字段

设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。

表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。

注意：

冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。

#### MySQL数据库cpu飙升到500%的话他怎么处理？

当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。

如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。

一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。

也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等

#### 大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：

限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；
读/写分离：经典的数据库拆分方案，主库负责写，从库负责读；
缓存：使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；
还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表

##### 垂直分区：

- ![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219114936305.png)

  - 根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

  - 简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。如下图所示，这样来说大家应该就更容易理解了。

- 垂直拆分的优点：
  - 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。

- 垂直拆分的缺点：
  - 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

- 垂直分表
  - 把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219114945112.png)

适用场景
缺点

有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差
对于应用层来说，逻辑算法增加开发成本
管理冗余列，查询所有数据需要join操作
1、如果一个表中某些列常用，另外一些列不常用
2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数

##### 水平分区：

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。
水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。
水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join性能较差，逻辑复杂。
《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

##### 水平分表：

表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219115041905.png)

适用场景
水平切分的缺点
下面补充一下数据库分片的两种常见方案：

客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。
中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。
1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作
2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数
1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。
2、需要把数据存放在多个介质上。
分库分表后面临的问题

事务支持 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。
跨库join
只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。分库分表方案产品
跨节点的count,order by,group by以及聚合函数问题 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。
数据迁移，容量规划，扩容等问题 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。
ID问题
一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略
UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。Twitter的分布式自增ID算法Snowflake 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。

跨分片的排序分页
般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219115115932.jpeg)

#### MySQL的复制原理以及流程

主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。

主从复制的作用

主数据库出现问题，可以切换到从数据库。
可以进行数据库层面的读写分离。
可以在从数据库上进行日常备份。
MySQL主从复制解决的问题

数据分布：随意开始或停止复制，并在不同地理位置分布数据备份
负载均衡：降低单个服务器的压力
高可用和故障切换：帮助应用程序避免单点失败
升级测试：可以用更高版本的MySQL作为从库
MySQL主从复制工作原理

在主库上把数据更高记录到二进制日志
从库将主库的日志复制到自己的中继日志
从库读取中继日志的事件，将其重放到从库数据中
基本原理流程，3个线程以及之间的关联

主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；

从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；

从：sql执行线程——执行relay log中的语句；

复制过程

![img](https://pledge99.oss-cn-beijing.aliyuncs.com/img/format,png-20211219115134035.jpeg)

Binary log：主数据库的二进制日志

Relay log：从服务器的中继日志

第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。

第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。

第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。

#### 读写分离有哪些解决方案？

读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。

方案一

使用mysql-proxy代理

优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用

缺点：降低性能， 不支持事务

方案二

使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。
如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。

方案三

使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.

缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。

#### 备份计划，mysqldump以及xtranbackup的实现原理

(1)备份计划

视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。

100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。

(2)备份恢复时间

物理备份恢复快，逻辑备份恢复慢

这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考

20G的2分钟（mysqldump）

80G的30分钟(mysqldump)

111G的30分钟（mysqldump)

288G的3小时（xtra)

3T的4小时（xtra)

逻辑导入时间一般是备份时间的5倍以上

(3)备份恢复失败如何处理

首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。

(4)mysqldump和xtrabackup实现原理

mysqldump

mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务

Xtrabackup:

xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交

概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事

情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。

#### 数据表损坏的修复方式有哪些？

使用 myisamchk 来修复，具体步骤：

1）修复前将mysql服务停止。
2）打开命令行方式，然后进入到mysql的/bin目录。
3）执行myisamchk –recover 数据库所在路径/*.MYI
使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）



### 计算机网络

#### 1、谈谈TCP 和 UDP的区别？

- **<font color='red'>TCP协议：</font>**【先建立连接，再传输-------打电话】
  - 使用TCP协议前，须先建立TCP连接，形成传输数据通道
  - 传输前，采用“三次握手” 方式，点对点通信， <font color='red'>是可靠的</font>
  - TCP协议进行通信的两个应用进程：客户端、 服务端。
  - 在连接中<font color='red'>可进行大数据量的传输</font>
  - 传输完毕，<font color='red'>需释放已建立的连接， 效率低</font>
- <font color='red'>**UDP协议：**</font>【直接传输-------发短信】
  - 将数据、源、目的封装成数据包，<font color='red'> 不需要建立连接</font>
  - 每个数据报的大小限制在64K内
  - 发送不管对方是否准备好，接收方收到也不确认， 故是不可靠的
  - 可以广播发送
  - 发送数据结束时<font color='red'>无需释放资源，开销小，速度快</font>

#### Http与Https的基本概念和他们的区别

http的中文叫做超文本传输协议,它负责完成客户端到服务端的一系列操作,是专门用来传输注入HTML的超媒体文档等web内容的协议,它是基于传输层的TCP协议的应用层协议

https:https是基于安全套接字的http协议,也可以理解为是http+ssl/tls(数字证书)的组合

http和https的区别:

- HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头
- HTTP 是不安全的，而 HTTPS 是安全的
- HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443
- 在 OSI 网络模型中，HTTPS的加密是在传输层完成的,因为SSL是位于传输层的,TLS的前身是SSL,所以同理
- HTTP无需认证证书,而https需要认证证书 

> 小结：简单来说http是用来进行html等超媒体传输的,但是http不安全,为了安全,使用证书SSL和HTTP的方式进行数据传输,也就是HTTPS 

#### HTTPS工作原理

- 首先服务端给客户端传输证书,这个证书就是公钥,只是包含了很多的信息,比如说证书的办法机构,证书的过期时间
- 客户端进行证书的解析,比如说验证办法机构,过期时间,如果发现没有任何问题,就生成一个随机值(私钥),然后用证书对这个私钥进行加密,并发送给服务端
- 服务端使用私钥将这个信息进行解密,得到客户端的私钥,然后客户端和服务端就可以通过这个私钥进行通信了
- 服务端将消息进行对称加密(简单来说就是讲消息和私钥进行混合,除非知道私钥否则服务进行解密),私钥正好只有客户端和服务端知道,所以信息就比较安全了
- 服务端将进行对称加密后的消息进行传送
- 客户端使用私钥进行信息的解密

> 小结：https就是使用了非对称加密(一对公私钥进行加密解密)进行公钥传输,然后客户端通过公钥加密将自己的私钥发给服务端,以后就可以使用这个私钥进行消息的收发了(图文方式的https的加密原理,可以点击链接:到我的另一篇博客进行学习)

#### 常用的HTTP方法有哪些

- GET 从服务器获得资源
- POST 客户端向服务器提交资源
- PUT 修改服务器相关资源  (已经很少用)
- DELETE 删除服务器相关资源  (已经很少用)

> 小结：我基本用的是get和post,其余的两个基本没用过(被自己菜醒)

#### 2、Get和Post请求的区别

Post：请求大小无限制，向服务器提交数据后返回给前端，速度慢，安全

Get：请求大小有限制，直接响应，速度快，不安全。



### 计算机操作系统

#### 1、CPU调度算法

先来先付服务算法

短作业优先算法

最短剩余时间算法

高响应比优先调度算法

## 2021年寒假实习

